{
  "version": 3,
  "sources": ["../src/resolveBinary.ts"],
  "sourcesContent": ["import Debug from '@prisma/debug'\nimport { plusX } from '@prisma/engine-core'\nimport { getEnginesPath } from '@prisma/engines'\nimport { BinaryType } from '@prisma/fetch-engine'\nimport { getNodeAPIName, getPlatform } from '@prisma/get-platform'\nimport fs from 'fs'\nimport makeDir from 'make-dir'\nimport path from 'path'\nimport tempDir from 'temp-dir'\nimport { promisify } from 'util'\n\nconst readFile = promisify(fs.readFile)\nconst writeFile = promisify(fs.writeFile)\nconst debug = Debug('prisma:resolveBinary')\n\nasync function getBinaryName(name: BinaryType): Promise<string> {\n  const platform = await getPlatform()\n  const extension = platform === 'windows' ? '.exe' : ''\n\n  if (name === BinaryType.libqueryEngine) {\n    return getNodeAPIName(platform, 'fs')\n  }\n  return `${name}-${platform}${extension}`\n}\nexport const engineEnvVarMap = {\n  [BinaryType.queryEngine]: 'PRISMA_QUERY_ENGINE_BINARY',\n  [BinaryType.libqueryEngine]: 'PRISMA_QUERY_ENGINE_LIBRARY',\n  [BinaryType.migrationEngine]: 'PRISMA_MIGRATION_ENGINE_BINARY',\n  [BinaryType.introspectionEngine]: 'PRISMA_INTROSPECTION_ENGINE_BINARY',\n  [BinaryType.prismaFmt]: 'PRISMA_FMT_BINARY',\n}\nexport { BinaryType }\nexport async function resolveBinary(\n  name: BinaryType,\n  proposedPath?: string,\n): Promise<string> {\n  if (\n    proposedPath &&\n    !proposedPath.startsWith('/snapshot/') &&\n    fs.existsSync(proposedPath)\n  ) {\n    return proposedPath\n  }\n  // tslint:disable-next-line\n\n  const envVar = engineEnvVarMap[name]\n\n  if (process.env[envVar]) {\n    if (!fs.existsSync(process.env[envVar]!)) {\n      throw new Error(\n        `Env var ${envVar} is provided, but provided path ${process.env[envVar]} can't be resolved.`,\n      )\n    }\n    return process.env[envVar]!\n  }\n\n  const dir = eval('__dirname')\n\n  const binaryName = await getBinaryName(name)\n\n  let prismaPath = path.join(getEnginesPath(), binaryName)\n  if (fs.existsSync(prismaPath)) {\n    return maybeCopyToTmp(prismaPath)\n  }\n  // for pkg\n  prismaPath = path.join(__dirname, '..', binaryName)\n  if (fs.existsSync(prismaPath)) {\n    return maybeCopyToTmp(prismaPath)\n  }\n\n  prismaPath = path.join(__dirname, '../..', binaryName)\n  if (fs.existsSync(prismaPath)) {\n    return maybeCopyToTmp(prismaPath)\n  }\n\n  // needed to come from @prisma/client/generator-build to @prisma/client/runtime\n  prismaPath = path.join(__dirname, '../runtime', binaryName)\n  if (fs.existsSync(prismaPath)) {\n    return maybeCopyToTmp(prismaPath)\n  }\n\n  throw new Error(\n    `Could not find ${name} binary. Searched in ${path.join(\n      dir,\n      '..',\n      binaryName,\n    )} and ${path.join(dir, '../..', binaryName)}`,\n  )\n}\n\nexport async function maybeCopyToTmp(file: string): Promise<string> {\n  // in this case, we are in a \"pkg\" context with a virtual fs\n  // to make this work, we need to copy the binary to /tmp and execute it from there\n\n  const dir = eval('__dirname')\n  if (dir.startsWith('/snapshot/')) {\n    const targetDir = path.join(tempDir, 'prisma-binaries')\n    await makeDir(targetDir)\n    const target = path.join(targetDir, path.basename(file))\n    const data = await readFile(file)\n    await writeFile(target, data)\n    // We have to read and write until https://github.com/zeit/pkg/issues/639\n    // is resolved\n    // await copyFile(file, target)\n    plusX(target)\n    return target\n  }\n\n  return file\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,mBAAkB;AAClB,yBAAsB;AACtB,qBAA+B;AAC/B,0BAA2B;AAC3B,0BAA4C;AAC5C,gBAAe;AACf,sBAAoB;AACpB,kBAAiB;AACjB,sBAAoB;AACpB,kBAA0B;AAE1B,MAAM,WAAW,2BAAU,kBAAG;AAC9B,MAAM,YAAY,2BAAU,kBAAG;AAC/B,MAAM,QAAQ,0BAAM;AAEpB,6BAA6B,MAAmC;AAC9D,QAAM,WAAW,MAAM;AACvB,QAAM,YAAY,aAAa,YAAY,SAAS;AAEpD,MAAI,SAAS,+BAAW,gBAAgB;AACtC,WAAO,wCAAe,UAAU;AAAA;AAElC,SAAO,GAAG,QAAQ,WAAW;AAAA;AAExB,MAAM,kBAAkB;AAAA,GAC5B,+BAAW,cAAc;AAAA,GACzB,+BAAW,iBAAiB;AAAA,GAC5B,+BAAW,kBAAkB;AAAA,GAC7B,+BAAW,sBAAsB;AAAA,GACjC,+BAAW,YAAY;AAAA;AAG1B,6BACE,MACA,cACiB;AACjB,MACE,gBACA,CAAC,aAAa,WAAW,iBACzB,kBAAG,WAAW,eACd;AACA,WAAO;AAAA;AAIT,QAAM,SAAS,gBAAgB;AAE/B,MAAI,QAAQ,IAAI,SAAS;AACvB,QAAI,CAAC,kBAAG,WAAW,QAAQ,IAAI,UAAW;AACxC,YAAM,IAAI,MACR,WAAW,yCAAyC,QAAQ,IAAI;AAAA;AAGpE,WAAO,QAAQ,IAAI;AAAA;AAGrB,QAAM,MAAM,KAAK;AAEjB,QAAM,aAAa,MAAM,cAAc;AAEvC,MAAI,aAAa,oBAAK,KAAK,sCAAkB;AAC7C,MAAI,kBAAG,WAAW,aAAa;AAC7B,WAAO,eAAe;AAAA;AAGxB,eAAa,oBAAK,KAAK,WAAW,MAAM;AACxC,MAAI,kBAAG,WAAW,aAAa;AAC7B,WAAO,eAAe;AAAA;AAGxB,eAAa,oBAAK,KAAK,WAAW,SAAS;AAC3C,MAAI,kBAAG,WAAW,aAAa;AAC7B,WAAO,eAAe;AAAA;AAIxB,eAAa,oBAAK,KAAK,WAAW,cAAc;AAChD,MAAI,kBAAG,WAAW,aAAa;AAC7B,WAAO,eAAe;AAAA;AAGxB,QAAM,IAAI,MACR,kBAAkB,4BAA4B,oBAAK,KACjD,KACA,MACA,mBACO,oBAAK,KAAK,KAAK,SAAS;AAAA;AAIrC,8BAAqC,MAA+B;AAIlE,QAAM,MAAM,KAAK;AACjB,MAAI,IAAI,WAAW,eAAe;AAChC,UAAM,YAAY,oBAAK,KAAK,yBAAS;AACrC,UAAM,6BAAQ;AACd,UAAM,SAAS,oBAAK,KAAK,WAAW,oBAAK,SAAS;AAClD,UAAM,OAAO,MAAM,SAAS;AAC5B,UAAM,UAAU,QAAQ;AAIxB,kCAAM;AACN,WAAO;AAAA;AAGT,SAAO;AAAA;",
  "names": []
}
