'use strict';

var _objectSpread = require('@babel/runtime/helpers/objectSpread2');
var core = require('./core-fe91e1fc.cjs.prod.js');
var sqlite = require('./sqlite-376d1367.cjs.prod.js');
var _objectWithoutProperties = require('@babel/runtime/helpers/objectWithoutProperties');
var graphqlTsSchema = require('./graphql-ts-schema-81d4ca0a.cjs.prod.js');
var graphql$1 = require('graphql');
var graphqlErrors = require('./graphql-errors-2ce72a8b.cjs.prod.js');
var Path = require('path');
var fs = require('fs-extra');
require('fast-glob');
require('prettier');
require('resolve');
var hashString = require('@emotion/hash');
var adminMetaGraphql = require('./admin-meta-graphql-c4e50813.cjs.prod.js');
require('@graphql-tools/schema');
var graphqlTsSchema$1 = require('@graphql-ts/schema');
var session_dist_keystone = require('../session/dist/keystone.cjs.prod.js');
var _classPrivateFieldInitSpec = require('@babel/runtime/helpers/classPrivateFieldInitSpec');
var _classPrivateFieldGet = require('@babel/runtime/helpers/classPrivateFieldGet');
var _classPrivateFieldSet = require('@babel/runtime/helpers/classPrivateFieldSet');
var pLimit = require('p-limit');
var typesForLists = require('./types-for-lists-5a8b5796.cjs.prod.js');
var apiWithContext = require('@graphql-ts/schema/api-with-context');
var apiWithoutContext = require('@graphql-ts/schema/api-without-context');
var uuid = require('uuid');
var fromBuffer = require('image-type');
var imageSize = require('image-size');
var fields_types_image_utils_dist_keystone = require('../fields/types/image/utils/dist/keystone.cjs.prod.js');
var fetch = require('node-fetch');
var FormData = require('form-data');
var crypto = require('crypto');
var stream = require('stream');
var filenamify = require('filenamify');
var slugify = require('@sindresorhus/slugify');
var fields_types_file_utils_dist_keystone = require('../fields/types/file/utils/dist/keystone.cjs.prod.js');
var cuid = require('cuid');
var packagePath = require('./package-path-6740a0e1.cjs.prod.js');

function _interopDefault (e) { return e && e.__esModule ? e : { 'default': e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}

var Path__namespace = /*#__PURE__*/_interopNamespace(Path);
var fs__default = /*#__PURE__*/_interopDefault(fs);
var hashString__default = /*#__PURE__*/_interopDefault(hashString);
var pLimit__default = /*#__PURE__*/_interopDefault(pLimit);
var fromBuffer__default = /*#__PURE__*/_interopDefault(fromBuffer);
var imageSize__default = /*#__PURE__*/_interopDefault(imageSize);
var fetch__default = /*#__PURE__*/_interopDefault(fetch);
var FormData__default = /*#__PURE__*/_interopDefault(FormData);
var crypto__default = /*#__PURE__*/_interopDefault(crypto);
var filenamify__default = /*#__PURE__*/_interopDefault(filenamify);
var slugify__default = /*#__PURE__*/_interopDefault(slugify);

function createAdminMeta(config, initialisedLists) {
  const {
    ui,
    lists,
    session
  } = config;
  const adminMetaRoot = {
    enableSessionItem: (ui === null || ui === void 0 ? void 0 : ui.enableSessionItem) || false,
    enableSignout: session !== undefined,
    listsByKey: {},
    lists: [],
    views: []
  };
  const omittedLists = [];

  for (const [key, list] of Object.entries(initialisedLists)) {
    var _ref, _listConfig$ui, _listConfig$ui2, _listConfig$ui2$listV, _ref2, _listConfig$ui$descri, _listConfig$ui3, _listConfig$ui$listVi, _listConfig$ui4, _listConfig$ui4$listV, _ref3, _listConfig$ui5, _listConfig$ui5$listV;

    const listConfig = lists[key];

    if (list.graphql.isEnabled.query === false) {
      // If graphql querying is disabled on the list,
      // push the key into the ommittedLists array for use further down in the procedure and skip.
      omittedLists.push(key);
      continue;
    } // Default the labelField to `name`, `label`, or `title` if they exist; otherwise fall back to `id`


    const labelField = (_ref = (_listConfig$ui = listConfig.ui) === null || _listConfig$ui === void 0 ? void 0 : _listConfig$ui.labelField) !== null && _ref !== void 0 ? _ref : listConfig.fields.label ? 'label' : listConfig.fields.name ? 'name' : listConfig.fields.title ? 'title' : 'id';
    let initialColumns;

    if ((_listConfig$ui2 = listConfig.ui) !== null && _listConfig$ui2 !== void 0 && (_listConfig$ui2$listV = _listConfig$ui2.listView) !== null && _listConfig$ui2$listV !== void 0 && _listConfig$ui2$listV.initialColumns) {
      // If they've asked for a particular thing, give them that thing
      initialColumns = listConfig.ui.listView.initialColumns;
    } else {
      // Otherwise, we'll start with the labelField on the left and then add
      // 2 more fields to the right of that. We don't include the 'id' field
      // unless it happened to be the labelField
      initialColumns = [labelField, ...Object.keys(list.fields).filter(fieldKey => list.fields[fieldKey].graphql.isEnabled.read).filter(fieldKey => fieldKey !== labelField).filter(fieldKey => fieldKey !== 'id')].slice(0, 3);
    }

    adminMetaRoot.listsByKey[key] = {
      key,
      labelField,
      description: (_ref2 = (_listConfig$ui$descri = (_listConfig$ui3 = listConfig.ui) === null || _listConfig$ui3 === void 0 ? void 0 : _listConfig$ui3.description) !== null && _listConfig$ui$descri !== void 0 ? _listConfig$ui$descri : listConfig.description) !== null && _ref2 !== void 0 ? _ref2 : null,
      label: list.adminUILabels.label,
      singular: list.adminUILabels.singular,
      plural: list.adminUILabels.plural,
      path: list.adminUILabels.path,
      fields: [],
      pageSize: (_listConfig$ui$listVi = (_listConfig$ui4 = listConfig.ui) === null || _listConfig$ui4 === void 0 ? void 0 : (_listConfig$ui4$listV = _listConfig$ui4.listView) === null || _listConfig$ui4$listV === void 0 ? void 0 : _listConfig$ui4$listV.pageSize) !== null && _listConfig$ui$listVi !== void 0 ? _listConfig$ui$listVi : 50,
      initialColumns,
      initialSort: (_ref3 = (_listConfig$ui5 = listConfig.ui) === null || _listConfig$ui5 === void 0 ? void 0 : (_listConfig$ui5$listV = _listConfig$ui5.listView) === null || _listConfig$ui5$listV === void 0 ? void 0 : _listConfig$ui5$listV.initialSort) !== null && _ref3 !== void 0 ? _ref3 : null,
      // TODO: probably remove this from the GraphQL schema and here
      itemQueryName: key,
      listQueryName: list.pluralGraphQLName
    };
    adminMetaRoot.lists.push(adminMetaRoot.listsByKey[key]);
  }

  let uniqueViewCount = -1;
  const stringViewsToIndex = {};

  function getViewId(view) {
    if (stringViewsToIndex[view] !== undefined) {
      return stringViewsToIndex[view];
    }

    uniqueViewCount++;
    stringViewsToIndex[view] = uniqueViewCount;
    adminMetaRoot.views.push(view);
    return uniqueViewCount;
  } // Populate .fields array


  for (const [key, list] of Object.entries(initialisedLists)) {
    var _config$lists$key$ui$, _config$lists$key$ui, _config$lists$key$ui2;

    if (omittedLists.includes(key)) continue;
    const searchFields = new Set((_config$lists$key$ui$ = (_config$lists$key$ui = config.lists[key].ui) === null || _config$lists$key$ui === void 0 ? void 0 : _config$lists$key$ui.searchFields) !== null && _config$lists$key$ui$ !== void 0 ? _config$lists$key$ui$ : []);

    if (searchFields.has('id')) {
      throw new Error(`The ui.searchFields option on the ${key} list includes 'id'. Lists can always be searched by an item's id so it must not be specified as a search field`);
    }

    const whereInputFields = list.types.where.graphQLType.getFields();

    if (((_config$lists$key$ui2 = config.lists[key].ui) === null || _config$lists$key$ui2 === void 0 ? void 0 : _config$lists$key$ui2.searchFields) === undefined) {
      const labelField = adminMetaRoot.listsByKey[key].labelField;
      const potentialFilterField = whereInputFields[`${labelField}_contains_i`] || whereInputFields[`${labelField}_contains`];

      if ((potentialFilterField === null || potentialFilterField === void 0 ? void 0 : potentialFilterField.type) === graphql$1.GraphQLString) {
        searchFields.add(labelField);
      }
    }

    for (const [fieldKey, field] of Object.entries(list.fields)) {
      var _field$label, _field$ui;

      // If the field is a relationship field and is related to an omitted list, skip.
      if (field.dbField.kind === 'relation' && omittedLists.includes(field.dbField.list)) continue; // FIXME: Disabling this entirely for now until the Admin UI can properly
      // handle `omit: ['read']` correctly.

      if (field.graphql.isEnabled.read === false) continue;
      let search = null;

      if (searchFields.has(fieldKey)) {
        var _whereInputFields$, _whereInputFields$2;

        if (((_whereInputFields$ = whereInputFields[`${fieldKey}_contains_i`]) === null || _whereInputFields$ === void 0 ? void 0 : _whereInputFields$.type) === graphql$1.GraphQLString) {
          search = 'insensitive';
        } else if (((_whereInputFields$2 = whereInputFields[`${fieldKey}_contains`]) === null || _whereInputFields$2 === void 0 ? void 0 : _whereInputFields$2.type) === graphql$1.GraphQLString) {
          search = 'default';
        } else {
          throw new Error(`The ui.searchFields option on the ${key} list includes '${fieldKey}' but that field doesn't have a contains filter that accepts a GraphQL String`);
        }
      }

      adminMetaRoot.listsByKey[key].fields.push({
        label: (_field$label = field.label) !== null && _field$label !== void 0 ? _field$label : graphqlErrors.humanize(fieldKey),
        viewsIndex: getViewId(field.views),
        customViewsIndex: ((_field$ui = field.ui) === null || _field$ui === void 0 ? void 0 : _field$ui.views) === undefined ? null : getViewId(field.ui.views),
        fieldMeta: null,
        path: fieldKey,
        listKey: key,
        search
      });
    }
  } // we do this seperately to the above so that fields can check other fields to validate their config or etc.
  // (ofc they won't necessarily be able to see other field's fieldMeta)


  for (const [key, list] of Object.entries(initialisedLists)) {
    if (list.graphql.isEnabled.query === false) continue;

    for (const fieldMetaRootVal of adminMetaRoot.listsByKey[key].fields) {
      var _list$fields$fieldMet, _list$fields$fieldMet2, _list$fields$fieldMet3;

      const dbField = list.fields[fieldMetaRootVal.path].dbField; // If the field is a relationship field and is related to an omitted list, skip.

      if (dbField.kind === 'relation' && omittedLists.includes(dbField.list)) {
        continue;
      }

      fieldMetaRootVal.fieldMeta = (_list$fields$fieldMet = (_list$fields$fieldMet2 = (_list$fields$fieldMet3 = list.fields[fieldMetaRootVal.path]).getAdminMeta) === null || _list$fields$fieldMet2 === void 0 ? void 0 : _list$fields$fieldMet2.call(_list$fields$fieldMet3, adminMetaRoot)) !== null && _list$fields$fieldMet !== void 0 ? _list$fields$fieldMet : null;
    }
  }

  return adminMetaRoot;
}

function serializePathForImport(path) {
  // JSON.stringify is important here because it will escape windows style paths(and any thing else that might potentially be in there)
  return JSON.stringify(path // Next is unhappy about imports that include .ts/tsx in them because TypeScript is unhappy with them because when doing a TypeScript compilation with tsc, the imports won't be written so they would be wrong there
  .replace(/\.tsx?$/, '').replace(new RegExp(`\\${Path__namespace["default"].sep}`, 'g'), '/'));
}

const appTemplate = (adminMetaRootVal, graphQLSchema, {
  configFileExists,
  projectAdminPath
}, apiPath) => {
  const result = graphql$1.executeSync({
    document: adminMetaGraphql.staticAdminMetaQuery,
    schema: graphQLSchema,
    contextValue: {
      isAdminUIBuildProcess: true
    }
  });

  if (result.errors) {
    throw result.errors[0];
  }

  const {
    adminMeta
  } = result.data.keystone;
  const adminMetaQueryResultHash = hashString__default["default"](JSON.stringify(adminMeta));
  const allViews = adminMetaRootVal.views.map(views => {
    const viewPath = Path__namespace["default"].isAbsolute(views) ? Path__namespace["default"].relative(Path__namespace["default"].join(projectAdminPath, 'pages'), views) : views;
    return serializePathForImport(viewPath);
  }); // -- TEMPLATE START

  return `import { getApp } from '@keystone-next/keystone/___internal-do-not-use-will-break-in-patch/admin-ui/pages/App';

${allViews.map((views, i) => `import * as view${i} from ${views};`).join('\n')}

${configFileExists ? `import * as adminConfig from "../../../admin/config";` : 'var adminConfig = {};'}

export default getApp({
  lazyMetadataQuery: ${JSON.stringify(getLazyMetadataQuery(graphQLSchema, adminMeta))},
  fieldViews: [${allViews.map((_, i) => `view${i}`)}],
  adminMetaHash: "${adminMetaQueryResultHash}",
  adminConfig: adminConfig,
  apiPath: "${apiPath}",
});
`; // -- TEMPLATE END
};

function getLazyMetadataQuery(graphqlSchema, adminMeta) {
  const selections = graphql$1.parse(`fragment x on y {
    keystone {
      adminMeta {
        lists {
          key
          isHidden
          fields {
            path
            createView {
              fieldMode
            }
          }
        }
      }
    }
  }`).definitions[0].selectionSet.selections;
  const queryType = graphqlSchema.getQueryType();

  if (queryType) {
    const getListByKey = name => adminMeta.lists.find(({
      key
    }) => key === name);

    const fields = queryType.getFields();

    if (fields['authenticatedItem'] !== undefined) {
      const authenticatedItemType = fields['authenticatedItem'].type;

      if (!(authenticatedItemType instanceof graphql$1.GraphQLUnionType) || authenticatedItemType.name !== 'AuthenticatedItem') {
        throw new Error(`The type of Query.authenticatedItem must be a type named AuthenticatedItem and be a union of types that refer to Keystone lists but it is "${authenticatedItemType.toString()}"`);
      }

      for (const type of authenticatedItemType.getTypes()) {
        const fields = type.getFields();
        const list = getListByKey(type.name);

        if (list === undefined) {
          throw new Error(`All members of the AuthenticatedItem union must refer to Keystone lists but "${type.name}" is in the AuthenticatedItem union but is not a Keystone list`);
        }

        let labelGraphQLField = fields[list.labelField];

        if (labelGraphQLField === undefined) {
          throw new Error(`The labelField for the list "${list.key}" is "${list.labelField}" but the GraphQL type does not have a field named "${list.labelField}"`);
        }

        let labelGraphQLFieldType = labelGraphQLField.type;

        if (labelGraphQLFieldType instanceof graphql$1.GraphQLNonNull) {
          labelGraphQLFieldType = labelGraphQLFieldType.ofType;
        }

        if (!(labelGraphQLFieldType instanceof graphql$1.GraphQLScalarType)) {
          throw new Error(`Label fields must be scalar GraphQL types but the labelField "${list.labelField}" on the list "${list.key}" is not a scalar type`);
        }

        const requiredArgs = labelGraphQLField.args.filter(arg => arg.defaultValue === undefined && arg.type instanceof graphql$1.GraphQLNonNull);

        if (requiredArgs.length) {
          throw new Error(`Label fields must have no required arguments but the labelField "${list.labelField}" on the list "${list.key}" has a required argument "${requiredArgs[0].name}"`);
        }
      }

      selections.push({
        kind: 'Field',
        name: {
          kind: 'Name',
          value: 'authenticatedItem'
        },
        selectionSet: {
          kind: 'SelectionSet',
          selections: authenticatedItemType.getTypes().map(({
            name
          }) => ({
            kind: 'InlineFragment',
            typeCondition: {
              kind: 'NamedType',
              name: {
                kind: 'Name',
                value: name
              }
            },
            selectionSet: {
              kind: 'SelectionSet',
              selections: [{
                kind: 'Field',
                name: {
                  kind: 'Name',
                  value: 'id'
                }
              }, {
                kind: 'Field',
                name: {
                  kind: 'Name',
                  value: getListByKey(name).labelField
                }
              }]
            }
          }))
        }
      });
    }
  } // We're returning the complete query AST here for explicit-ness


  return {
    kind: 'Document',
    definitions: [{
      kind: 'OperationDefinition',
      operation: 'query',
      selectionSet: {
        kind: 'SelectionSet',
        selections
      }
    }]
  };
}

const homeTemplate = `export { HomePage as default } from '@keystone-next/keystone/___internal-do-not-use-will-break-in-patch/admin-ui/pages/HomePage';
`;

const listTemplate = listKey => `import { getListPage } from '@keystone-next/keystone/___internal-do-not-use-will-break-in-patch/admin-ui/pages/ListPage';

export default getListPage(${JSON.stringify({
  listKey
})});
`;

const itemTemplate = listKey => `import { getItemPage } from '@keystone-next/keystone/___internal-do-not-use-will-break-in-patch/admin-ui/pages/ItemPage';

export default getItemPage(${JSON.stringify({
  listKey
})})
`;

const apiTemplate = `
import keystoneConfig from '../../../../keystone';
import { initConfig, createSystem, createApolloServerMicro } from '@keystone-next/keystone/system';
import { PrismaClient } from '.prisma/client';

const initializedKeystoneConfig = initConfig(keystoneConfig);
const { graphQLSchema, keystone, createContext } = createSystem(initializedKeystoneConfig, 'none', PrismaClient);
const apolloServer = createApolloServerMicro({
  graphQLSchema,
  createContext,
  sessionStrategy: initializedKeystoneConfig.session ? initializedKeystoneConfig.session() : undefined,
  graphqlConfig: initializedKeystoneConfig.graphql,
  connectionPromise: keystone.connect(),
});

export const config = {
  api: {
    bodyParser: false,
  },
};
export default apolloServer.createHandler({ path: initializedKeystoneConfig.graphql?.path || '/api/graphql' });
`;

const noAccessTemplate = session => `import { getNoAccessPage } from '@keystone-next/keystone/___internal-do-not-use-will-break-in-patch/admin-ui/pages/NoAccessPage';

export default getNoAccessPage(${JSON.stringify({
  sessionsEnabled: !!session
})})
`;

const pkgDir = Path__namespace.dirname(require.resolve('@keystone-next/keystone/package.json'));
const writeAdminFiles = (config, graphQLSchema, adminMeta, configFileExists, projectAdminPath) => {
  var _config$experimental, _config$graphql, _config$graphql2, _config$experimental2, _config$graphql3;

  if ((_config$experimental = config.experimental) !== null && _config$experimental !== void 0 && _config$experimental.enableNextJsGraphqlApiEndpoint && (_config$graphql = config.graphql) !== null && _config$graphql !== void 0 && _config$graphql.path && !config.graphql.path.startsWith('/api/')) {
    throw new Error('config.graphql.path must start with "/api/" when using config.experimental.enableNextJsGraphqlApiEndpoint');
  }

  return [...['next.config.js', 'tsconfig.json'].map(outputPath => ({
    mode: 'copy',
    inputPath: Path__namespace.join(pkgDir, 'static', outputPath),
    outputPath
  })), {
    mode: 'write',
    src: noAccessTemplate(config.session),
    outputPath: 'pages/no-access.js'
  }, {
    mode: 'write',
    src: appTemplate(adminMeta, graphQLSchema, {
      configFileExists,
      projectAdminPath
    }, ((_config$graphql2 = config.graphql) === null || _config$graphql2 === void 0 ? void 0 : _config$graphql2.path) || '/api/graphql'),
    outputPath: 'pages/_app.js'
  }, {
    mode: 'write',
    src: homeTemplate,
    outputPath: 'pages/index.js'
  }, ...adminMeta.lists.map(({
    path,
    key
  }) => ({
    mode: 'write',
    src: listTemplate(key),
    outputPath: `pages/${path}/index.js`
  })), ...adminMeta.lists.map(({
    path,
    key
  }) => ({
    mode: 'write',
    src: itemTemplate(key),
    outputPath: `pages/${path}/[id].js`
  })), ...((_config$experimental2 = config.experimental) !== null && _config$experimental2 !== void 0 && _config$experimental2.enableNextJsGraphqlApiEndpoint ? [{
    mode: 'write',
    src: apiTemplate,
    outputPath: `pages/${((_config$graphql3 = config.graphql) === null || _config$graphql3 === void 0 ? void 0 : _config$graphql3.path) || '/api/graphql'}.js`
  }] : [])];
};

const graphql = _objectSpread(_objectSpread({}, graphqlTsSchema.graphqlBoundToKeystoneContext), graphqlTsSchema$1.bindGraphQLSchemaAPIToContext());

function getAdminMetaSchema({
  config,
  graphQLSchema,
  lists,
  adminMeta: adminMetaRoot
}) {
  var _config$ui$isAccessAl, _config$ui;

  const isAccessAllowed = config.session === undefined ? undefined : (_config$ui$isAccessAl = (_config$ui = config.ui) === null || _config$ui === void 0 ? void 0 : _config$ui.isAccessAllowed) !== null && _config$ui$isAccessAl !== void 0 ? _config$ui$isAccessAl : ({
    session
  }) => session !== undefined;
  const jsonScalarType = graphQLSchema.getType('JSON');
  const jsonScalar = jsonScalarType ? graphql.scalar(graphql$1.assertScalarType(jsonScalarType)) : graphqlTsSchema.JSON;
  const queryModeEnumType = graphQLSchema.getType('QueryMode');
  const queryModeEnum = queryModeEnumType ? _objectSpread(_objectSpread({}, sqlite.QueryMode), {}, {
    graphQLType: graphql$1.assertEnumType(graphQLSchema.getType('QueryMode'))
  }) : sqlite.QueryMode;
  const KeystoneAdminUIFieldMeta = graphql.object()({
    name: 'KeystoneAdminUIFieldMeta',
    fields: {
      path: graphql.field({
        type: graphql.nonNull(graphql.String)
      }),
      label: graphql.field({
        type: graphql.nonNull(graphql.String)
      }),
      isOrderable: graphql.field({
        type: graphql.nonNull(graphql.Boolean),

        resolve(rootVal, args, context) {
          var _lists$rootVal$listKe;

          if ('isAdminUIBuildProcess' in context) {
            throw new Error('KeystoneAdminUIFieldMeta.isOrderable cannot be resolved during the build process');
          }

          if (!((_lists$rootVal$listKe = lists[rootVal.listKey].fields[rootVal.path].input) !== null && _lists$rootVal$listKe !== void 0 && _lists$rootVal$listKe.orderBy)) {
            return false;
          }

          const isOrderable = lists[rootVal.listKey].fields[rootVal.path].graphql.isEnabled.orderBy;

          if (typeof isOrderable === 'function') {
            return isOrderable({
              context,
              fieldKey: rootVal.path,
              listKey: rootVal.listKey,
              session: context.session
            });
          }

          return isOrderable;
        }

      }),
      isFilterable: graphql.field({
        type: graphql.nonNull(graphql.Boolean),

        resolve(rootVal, args, context) {
          var _lists$rootVal$listKe2;

          if ('isAdminUIBuildProcess' in context) {
            throw new Error('KeystoneAdminUIFieldMeta.isOrderable cannot be resolved during the build process');
          }

          if (!((_lists$rootVal$listKe2 = lists[rootVal.listKey].fields[rootVal.path].input) !== null && _lists$rootVal$listKe2 !== void 0 && _lists$rootVal$listKe2.where)) {
            return false;
          }

          const isFilterable = lists[rootVal.listKey].fields[rootVal.path].graphql.isEnabled.filter;

          if (typeof isFilterable === 'function') {
            return isFilterable({
              context,
              fieldKey: rootVal.path,
              listKey: rootVal.listKey,
              session: context.session
            });
          }

          return isFilterable !== null && isFilterable !== void 0 ? isFilterable : false;
        }

      }),
      fieldMeta: graphql.field({
        type: jsonScalar
      }),
      viewsIndex: graphql.field({
        type: graphql.nonNull(graphql.Int)
      }),
      customViewsIndex: graphql.field({
        type: graphql.Int
      }),
      createView: graphql.field({
        resolve(rootVal) {
          return {
            fieldPath: rootVal.path,
            listKey: rootVal.listKey
          };
        },

        type: graphql.nonNull(graphql.object()({
          name: 'KeystoneAdminUIFieldMetaCreateView',
          fields: {
            fieldMode: graphql.field({
              type: graphql.nonNull(graphql.enum({
                name: 'KeystoneAdminUIFieldMetaCreateViewFieldMode',
                values: graphql.enumValues(['edit', 'hidden'])
              })),

              async resolve(rootVal, args, context) {
                var _lists$rootVal$listKe3, _lists$rootVal$listKe4, _lists$rootVal$listKe5, _listConfig$ui, _listConfig$ui$create;

                if ('isAdminUIBuildProcess' in context) {
                  throw new Error('KeystoneAdminUIFieldMetaCreateView.fieldMode cannot be resolved during the build process');
                }

                if (!lists[rootVal.listKey].fields[rootVal.fieldPath].graphql.isEnabled.create) {
                  return 'hidden';
                }

                const listConfig = config.lists[rootVal.listKey];
                const sessionFunction = (_lists$rootVal$listKe3 = (_lists$rootVal$listKe4 = lists[rootVal.listKey].fields[rootVal.fieldPath].ui) === null || _lists$rootVal$listKe4 === void 0 ? void 0 : (_lists$rootVal$listKe5 = _lists$rootVal$listKe4.createView) === null || _lists$rootVal$listKe5 === void 0 ? void 0 : _lists$rootVal$listKe5.fieldMode) !== null && _lists$rootVal$listKe3 !== void 0 ? _lists$rootVal$listKe3 : (_listConfig$ui = listConfig.ui) === null || _listConfig$ui === void 0 ? void 0 : (_listConfig$ui$create = _listConfig$ui.createView) === null || _listConfig$ui$create === void 0 ? void 0 : _listConfig$ui$create.defaultFieldMode;
                return runMaybeFunction(sessionFunction, 'edit', {
                  session: context.session
                });
              }

            })
          }
        }))
      }),
      listView: graphql.field({
        resolve(rootVal) {
          return {
            fieldPath: rootVal.path,
            listKey: rootVal.listKey
          };
        },

        type: graphql.nonNull(graphql.object()({
          name: 'KeystoneAdminUIFieldMetaListView',
          fields: {
            fieldMode: graphql.field({
              type: graphql.nonNull(graphql.enum({
                name: 'KeystoneAdminUIFieldMetaListViewFieldMode',
                values: graphql.enumValues(['read', 'hidden'])
              })),

              async resolve(rootVal, args, context) {
                var _lists$rootVal$listKe6, _lists$rootVal$listKe7, _lists$rootVal$listKe8, _listConfig$ui2, _listConfig$ui2$listV;

                if ('isAdminUIBuildProcess' in context) {
                  throw new Error('KeystoneAdminUIFieldMetaListView.fieldMode cannot be resolved during the build process');
                }

                if (!lists[rootVal.listKey].fields[rootVal.fieldPath].graphql.isEnabled.read) {
                  return 'hidden';
                }

                const listConfig = config.lists[rootVal.listKey];
                const sessionFunction = (_lists$rootVal$listKe6 = (_lists$rootVal$listKe7 = lists[rootVal.listKey].fields[rootVal.fieldPath].ui) === null || _lists$rootVal$listKe7 === void 0 ? void 0 : (_lists$rootVal$listKe8 = _lists$rootVal$listKe7.listView) === null || _lists$rootVal$listKe8 === void 0 ? void 0 : _lists$rootVal$listKe8.fieldMode) !== null && _lists$rootVal$listKe6 !== void 0 ? _lists$rootVal$listKe6 : (_listConfig$ui2 = listConfig.ui) === null || _listConfig$ui2 === void 0 ? void 0 : (_listConfig$ui2$listV = _listConfig$ui2.listView) === null || _listConfig$ui2$listV === void 0 ? void 0 : _listConfig$ui2$listV.defaultFieldMode;
                return runMaybeFunction(sessionFunction, 'read', {
                  session: context.session
                });
              }

            })
          }
        }))
      }),
      itemView: graphql.field({
        args: {
          id: graphql.arg({
            type: graphql.ID
          })
        },

        resolve(rootVal, args) {
          var _args$id;

          return {
            fieldPath: rootVal.path,
            listKey: rootVal.listKey,
            itemId: (_args$id = args.id) !== null && _args$id !== void 0 ? _args$id : null
          };
        },

        type: graphql.object()({
          name: 'KeystoneAdminUIFieldMetaItemView',
          fields: {
            fieldMode: graphql.field({
              type: graphql.enum({
                name: 'KeystoneAdminUIFieldMetaItemViewFieldMode',
                values: graphql.enumValues(['edit', 'read', 'hidden'])
              }),

              resolve(rootVal, args, context) {
                var _ref, _lists$rootVal$listKe9, _lists$rootVal$listKe10, _lists$rootVal$listKe11, _listConfig$ui3, _listConfig$ui3$itemV;

                if ('isAdminUIBuildProcess' in context && rootVal.itemId !== null) {
                  throw new Error('KeystoneAdminUIFieldMetaItemView.fieldMode cannot be resolved during the build process if an id is provided');
                }

                if (!lists[rootVal.listKey].fields[rootVal.fieldPath].graphql.isEnabled.read) {
                  return 'hidden';
                } else if (!lists[rootVal.listKey].fields[rootVal.fieldPath].graphql.isEnabled.update) {
                  return 'read';
                }

                const listConfig = config.lists[rootVal.listKey];
                const sessionFunction = (_ref = (_lists$rootVal$listKe9 = (_lists$rootVal$listKe10 = lists[rootVal.listKey].fields[rootVal.fieldPath].ui) === null || _lists$rootVal$listKe10 === void 0 ? void 0 : (_lists$rootVal$listKe11 = _lists$rootVal$listKe10.itemView) === null || _lists$rootVal$listKe11 === void 0 ? void 0 : _lists$rootVal$listKe11.fieldMode) !== null && _lists$rootVal$listKe9 !== void 0 ? _lists$rootVal$listKe9 : (_listConfig$ui3 = listConfig.ui) === null || _listConfig$ui3 === void 0 ? void 0 : (_listConfig$ui3$itemV = _listConfig$ui3.itemView) === null || _listConfig$ui3$itemV === void 0 ? void 0 : _listConfig$ui3$itemV.defaultFieldMode) !== null && _ref !== void 0 ? _ref : 'edit';

                if (typeof sessionFunction === 'string') {
                  return sessionFunction;
                }

                if (rootVal.itemId === null) {
                  return null;
                }
                // to a variable and then returned

                let ret = fetchItemForItemViewFieldMode(context)(rootVal.listKey, rootVal.itemId).then(item => {
                  if (item === null) {
                    return 'hidden';
                  }

                  return runMaybeFunction(sessionFunction, 'edit', {
                    session: context.session,
                    item
                  });
                });
                return ret;
              }

            })
          }
        })
      }),
      search: graphql.field({
        type: queryModeEnum
      })
    }
  });
  const KeystoneAdminUISort = graphql.object()({
    name: 'KeystoneAdminUISort',
    fields: {
      field: graphql.field({
        type: graphql.nonNull(graphql.String)
      }),
      direction: graphql.field({
        type: graphql.nonNull(graphql.enum({
          name: 'KeystoneAdminUISortDirection',
          values: graphql.enumValues(['ASC', 'DESC'])
        }))
      })
    }
  });
  const KeystoneAdminUIListMeta = graphql.object()({
    name: 'KeystoneAdminUIListMeta',
    fields: {
      key: graphql.field({
        type: graphql.nonNull(graphql.String)
      }),
      itemQueryName: graphql.field({
        type: graphql.nonNull(graphql.String)
      }),
      listQueryName: graphql.field({
        type: graphql.nonNull(graphql.String)
      }),
      hideCreate: graphql.field({
        type: graphql.nonNull(graphql.Boolean),

        resolve(rootVal, args, context) {
          var _listConfig$ui4;

          if ('isAdminUIBuildProcess' in context) {
            throw new Error('KeystoneAdminUIListMeta.hideCreate cannot be resolved during the build process');
          }

          const listConfig = config.lists[rootVal.key];
          return runMaybeFunction((_listConfig$ui4 = listConfig.ui) === null || _listConfig$ui4 === void 0 ? void 0 : _listConfig$ui4.hideCreate, false, {
            session: context.session
          });
        }

      }),
      hideDelete: graphql.field({
        type: graphql.nonNull(graphql.Boolean),

        resolve(rootVal, args, context) {
          var _listConfig$ui5;

          if ('isAdminUIBuildProcess' in context) {
            throw new Error('KeystoneAdminUIListMeta.hideDelete cannot be resolved during the build process');
          }

          const listConfig = config.lists[rootVal.key];
          return runMaybeFunction((_listConfig$ui5 = listConfig.ui) === null || _listConfig$ui5 === void 0 ? void 0 : _listConfig$ui5.hideDelete, false, {
            session: context.session
          });
        }

      }),
      path: graphql.field({
        type: graphql.nonNull(graphql.String)
      }),
      label: graphql.field({
        type: graphql.nonNull(graphql.String)
      }),
      singular: graphql.field({
        type: graphql.nonNull(graphql.String)
      }),
      plural: graphql.field({
        type: graphql.nonNull(graphql.String)
      }),
      description: graphql.field({
        type: graphql.String
      }),
      initialColumns: graphql.field({
        type: graphql.nonNull(graphql.list(graphql.nonNull(graphql.String)))
      }),
      pageSize: graphql.field({
        type: graphql.nonNull(graphql.Int)
      }),
      labelField: graphql.field({
        type: graphql.nonNull(graphql.String)
      }),
      fields: graphql.field({
        type: graphql.nonNull(graphql.list(graphql.nonNull(KeystoneAdminUIFieldMeta)))
      }),
      initialSort: graphql.field({
        type: KeystoneAdminUISort
      }),
      isHidden: graphql.field({
        type: graphql.nonNull(graphql.Boolean),

        resolve(rootVal, args, context) {
          var _listConfig$ui6;

          if ('isAdminUIBuildProcess' in context) {
            throw new Error('KeystoneAdminUIListMeta.isHidden cannot be resolved during the build process');
          }

          const listConfig = config.lists[rootVal.key];
          return runMaybeFunction((_listConfig$ui6 = listConfig.ui) === null || _listConfig$ui6 === void 0 ? void 0 : _listConfig$ui6.isHidden, false, {
            session: context.session
          });
        }

      })
    }
  });
  const adminMeta = graphql.object()({
    name: 'KeystoneAdminMeta',
    fields: {
      enableSignout: graphql.field({
        type: graphql.nonNull(graphql.Boolean)
      }),
      enableSessionItem: graphql.field({
        type: graphql.nonNull(graphql.Boolean)
      }),
      lists: graphql.field({
        type: graphql.nonNull(graphql.list(graphql.nonNull(KeystoneAdminUIListMeta)))
      }),
      list: graphql.field({
        type: KeystoneAdminUIListMeta,
        args: {
          key: graphql.arg({
            type: graphql.nonNull(graphql.String)
          })
        },

        resolve(rootVal, {
          key
        }) {
          return rootVal.listsByKey[key];
        }

      })
    }
  });
  const KeystoneMeta = graphql.nonNull(graphql.object()({
    name: 'KeystoneMeta',
    fields: {
      adminMeta: graphql.field({
        type: graphql.nonNull(adminMeta),

        resolve(rootVal, args, context) {
          if ('isAdminUIBuildProcess' in context || isAccessAllowed === undefined) {
            return adminMetaRoot;
          }

          return Promise.resolve(isAccessAllowed(context)).then(isAllowed => {
            if (isAllowed) {
              return adminMetaRoot;
            } // TODO: ughhhhhh, we really need to talk about errors.
            // mostly unrelated to above: error or return null here(+ make field nullable)?s


            throw new Error('Access denied');
          });
        }

      })
    }
  }));
  const schemaConfig = graphQLSchema.toConfig();
  const queryTypeConfig = graphQLSchema.getQueryType().toConfig();
  return new graphql$1.GraphQLSchema(_objectSpread(_objectSpread({}, schemaConfig), {}, {
    types: schemaConfig.types.filter(x => x.name !== 'Query'),
    query: new graphql$1.GraphQLObjectType(_objectSpread(_objectSpread({}, queryTypeConfig), {}, {
      fields: _objectSpread(_objectSpread({}, queryTypeConfig.fields), {}, {
        keystone: {
          type: KeystoneMeta.graphQLType,

          resolve() {
            return {};
          }

        }
      })
    }))
  }));
}

function runMaybeFunction(sessionFunction, defaultValue, args) {
  if (typeof sessionFunction === 'function') {
    return sessionFunction(args);
  }

  if (typeof sessionFunction === 'undefined') {
    return defaultValue;
  }

  return sessionFunction;
}

const fetchItemForItemViewFieldMode = extendContext(context => {
  const lists = new Map();
  return (listKey, id) => {
    if (!lists.has(listKey)) {
      lists.set(listKey, new Map());
    }

    const items = lists.get(listKey);

    if (items.has(id)) {
      return items.get(id);
    }

    let promise = context.db[listKey].findOne({
      where: {
        id
      }
    });
    items.set(id, promise);
    return promise;
  };
});

function extendContext(cb) {
  const cache = new WeakMap();
  return context => {
    if (cache.has(context)) {
      return cache.get(context);
    }

    const result = cb(context);
    cache.set(context, result);
    return result;
  };
}

function getResolvedUniqueWheres(uniqueInputs, context, foreignList) {
  return uniqueInputs.map(async uniqueInput => {
    // Validate and resolve the input filter
    const uniqueWhere = await typesForLists.resolveUniqueWhereInput(uniqueInput, foreignList.fields, context); // Check whether the item exists

    const item = await context.db[foreignList.listKey].findOne({
      where: uniqueInput
    });

    if (item === null) {
      throw new Error('Unable to find item to connect to.');
    }

    return uniqueWhere;
  });
}

function resolveRelateToManyForCreateInput(nestedMutationState, context, foreignList, target) {
  return async value => {
    if (!Array.isArray(value.connect) && !Array.isArray(value.create)) {
      throw graphqlErrors.userInputError(`You must provide at least one field in to-many relationship inputs but none were provided at ${target}`);
    } // Perform queries for the connections


    const connects = Promise.allSettled(getResolvedUniqueWheres(value.connect || [], context, foreignList)); // Perform nested mutations for the creations

    const creates = Promise.allSettled((value.create || []).map(x => nestedMutationState.create(x, foreignList)));
    const [connectResult, createResult] = await Promise.all([connects, creates]); // Collect all the errors

    const errors = [...connectResult.filter(typesForLists.isRejected), ...createResult.filter(typesForLists.isRejected)].map(x => x.reason);

    if (errors.length) {
      throw new Error(`Unable to create and/or connect ${errors.length} ${target}`);
    }

    const result = {
      connect: [...connectResult, ...createResult].filter(typesForLists.isFulfilled).map(x => x.value)
    }; // Perform queries for the connections

    return result;
  };
}
function resolveRelateToManyForUpdateInput(nestedMutationState, context, foreignList, target) {
  return async value => {
    if (!Array.isArray(value.connect) && !Array.isArray(value.create) && !Array.isArray(value.disconnect) && !Array.isArray(value.set)) {
      throw graphqlErrors.userInputError(`You must provide at least one field in to-many relationship inputs but none were provided at ${target}`);
    }

    if (value.set && value.disconnect) {
      throw graphqlErrors.userInputError(`The set and disconnect fields cannot both be provided to to-many relationship inputs but both were provided at ${target}`);
    } // Perform queries for the connections


    const connects = Promise.allSettled(getResolvedUniqueWheres(value.connect || [], context, foreignList));
    const disconnects = Promise.allSettled(getResolvedUniqueWheres(value.disconnect || [], context, foreignList));
    const sets = Promise.allSettled(getResolvedUniqueWheres(value.set || [], context, foreignList)); // Perform nested mutations for the creations

    const creates = Promise.allSettled((value.create || []).map(x => nestedMutationState.create(x, foreignList)));
    const [connectResult, createResult, disconnectResult, setResult] = await Promise.all([connects, creates, disconnects, sets]); // Collect all the errors

    const errors = [...connectResult.filter(typesForLists.isRejected), ...createResult.filter(typesForLists.isRejected), ...disconnectResult.filter(typesForLists.isRejected), ...setResult.filter(typesForLists.isRejected)];

    if (errors.length) {
      throw new Error(`Unable to create, connect, disconnect and/or set ${errors.length} ${target}`);
    }

    return {
      // unlike all the other operations, an empty array isn't a no-op for set
      set: value.set ? setResult.filter(typesForLists.isFulfilled).map(x => x.value) : undefined,
      disconnect: disconnectResult.filter(typesForLists.isFulfilled).map(x => x.value),
      connect: [...connectResult, ...createResult].filter(typesForLists.isFulfilled).map(x => x.value)
    };
  };
}

async function handleCreateAndUpdate(value, nestedMutationState, context, foreignList, target) {
  if (value.connect) {
    // Validate and resolve the input filter
    const uniqueWhere = await typesForLists.resolveUniqueWhereInput(value.connect, foreignList.fields, context); // Check whether the item exists

    try {
      const item = await context.db[foreignList.listKey].findOne({
        where: value.connect
      });

      if (item === null) {
        throw new Error(`Unable to connect a ${target}`);
      }
    } catch (err) {
      throw new Error(`Unable to connect a ${target}`);
    }

    return {
      connect: uniqueWhere
    };
  } else if (value.create) {
    const createInput = value.create;
    let create = await (async () => {
      try {
        // Perform the nested create operation
        return await nestedMutationState.create(createInput, foreignList);
      } catch (err) {
        throw new Error(`Unable to create a ${target}`);
      }
    })();
    return {
      connect: {
        id: create.id
      }
    };
  }
}

function resolveRelateToOneForCreateInput(nestedMutationState, context, foreignList, target) {
  return async value => {
    const numOfKeys = Object.keys(value).length;

    if (numOfKeys !== 1) {
      throw graphqlErrors.userInputError(`Nested to-one mutations must provide exactly one field if they're provided but ${target} did not`);
    }

    return handleCreateAndUpdate(value, nestedMutationState, context, foreignList, target);
  };
}
function resolveRelateToOneForUpdateInput(nestedMutationState, context, foreignList, target) {
  return async value => {
    if (Object.keys(value).length !== 1) {
      throw graphqlErrors.userInputError(`Nested to-one mutations must provide exactly one field if they're provided but ${target} did not`);
    }

    if (value.connect || value.create) {
      return handleCreateAndUpdate(value, nestedMutationState, context, foreignList, target);
    } else if (value.disconnect) {
      return {
        disconnect: true
      };
    }
  };
}

async function getFilteredItem(list, context, uniqueWhere, accessFilters, operation) {
  if (accessFilters === false) {
    // Early exit if they want to exclude everything
    throw graphqlErrors.accessDeniedError(`You cannot perform the '${operation}' operation on the list '${list.listKey}'.`);
  } // Merge the filter access control and try to get the item.


  let where = typesForLists.mapUniqueWhereToWhere(list, uniqueWhere);

  if (typeof accessFilters === 'object') {
    where = {
      AND: [where, await typesForLists.resolveWhereInput(accessFilters, list, context)]
    };
  }

  const item = await typesForLists.runWithPrisma(context, list, model => model.findFirst({
    where
  }));

  if (item === null) {
    throw graphqlErrors.accessDeniedError(`You cannot perform the '${operation}' operation on the item '${JSON.stringify(uniqueWhere)}'. It may not exist.`);
  }

  return item;
}

async function getAccessControlledItemForDelete(list, context, uniqueWhere, accessFilters) {
  const operation = 'delete'; // Apply the filter access control. Will throw an accessDeniedError if the item isn't found.

  const item = await getFilteredItem(list, context, uniqueWhere, accessFilters, operation); // Apply item level access control

  const access = list.access.item[operation];
  const args = {
    operation,
    session: context.session,
    listKey: list.listKey,
    context,
    item
  }; // List level 'item' access control

  let result;

  try {
    result = await access(args);
  } catch (error) {
    throw graphqlErrors.extensionError('Access control', [{
      error,
      tag: `${args.listKey}.access.item.${args.operation}`
    }]);
  }

  const resultType = typeof result; // It's important that we don't cast objects to truthy values, as there's a strong chance that the user
  // has accidentally tried to return a filter.

  if (resultType !== 'boolean') {
    throw graphqlErrors.accessReturnError([{
      tag: `${args.listKey}.access.item.${args.operation}`,
      returned: resultType
    }]);
  }

  if (!result) {
    throw graphqlErrors.accessDeniedError(`You cannot perform the '${operation}' operation on the item '${JSON.stringify(uniqueWhere)}'. It may not exist.`);
  } // No field level access control for delete


  return item;
}
async function getAccessControlledItemForUpdate(list, context, uniqueWhere, accessFilters, inputData) {
  const operation = 'update'; // Apply the filter access control. Will throw an accessDeniedError if the item isn't found.

  const item = await getFilteredItem(list, context, uniqueWhere, accessFilters, operation); // Apply item level access control

  const access = list.access.item[operation];
  const args = {
    operation,
    session: context.session,
    listKey: list.listKey,
    context,
    item,
    inputData
  }; // List level 'item' access control

  let result;

  try {
    result = await access(args);
  } catch (error) {
    throw graphqlErrors.extensionError('Access control', [{
      error,
      tag: `${args.listKey}.access.item.${args.operation}`
    }]);
  }

  const resultType = typeof result; // It's important that we don't cast objects to truthy values, as there's a strong chance that the user
  // has accidentally tried to return a filter.

  if (resultType !== 'boolean') {
    throw graphqlErrors.accessReturnError([{
      tag: `${args.listKey}.access.item.${args.operation}`,
      returned: resultType
    }]);
  }

  if (!result) {
    throw graphqlErrors.accessDeniedError(`You cannot perform the '${operation}' operation on the item '${JSON.stringify(uniqueWhere)}'. It may not exist.`);
  } // Field level 'item' access control


  const nonBooleans = [];
  const fieldsDenied = [];
  const accessErrors = [];

  for (const fieldKey of Object.keys(inputData)) {
    let result;

    try {
      result = typeof list.fields[fieldKey].access[operation] === 'function' ? await list.fields[fieldKey].access[operation](_objectSpread(_objectSpread({}, args), {}, {
        fieldKey
      })) : access;
    } catch (error) {
      accessErrors.push({
        error,
        tag: `${args.listKey}.${fieldKey}.access.${args.operation}`
      });
      continue;
    }

    if (typeof result !== 'boolean') {
      nonBooleans.push({
        tag: `${args.listKey}.${fieldKey}.access.${args.operation}`,
        returned: typeof result
      });
    } else if (!result) {
      fieldsDenied.push(fieldKey);
    }
  }

  if (accessErrors.length) {
    throw graphqlErrors.extensionError('Access control', accessErrors);
  }

  if (nonBooleans.length) {
    throw graphqlErrors.accessReturnError(nonBooleans);
  }

  if (fieldsDenied.length) {
    throw graphqlErrors.accessDeniedError(`You cannot perform the '${operation}' operation on the item '${JSON.stringify(uniqueWhere)}'. You cannot ${operation} the fields ${JSON.stringify(fieldsDenied)}.`);
  }

  return item;
}
async function applyAccessControlForCreate(list, context, inputData) {
  const operation = 'create'; // Apply item level access control

  const access = list.access.item[operation];
  const args = {
    operation,
    session: context.session,
    listKey: list.listKey,
    context,
    inputData
  }; // List level 'item' access control

  let result;

  try {
    result = await access(args);
  } catch (error) {
    throw graphqlErrors.extensionError('Access control', [{
      error,
      tag: `${args.listKey}.access.item.${args.operation}`
    }]);
  }

  const resultType = typeof result; // It's important that we don't cast objects to truthy values, as there's a strong chance that the user
  // has accidentally tried to return a filter.

  if (resultType !== 'boolean') {
    throw graphqlErrors.accessReturnError([{
      tag: `${args.listKey}.access.item.${args.operation}`,
      returned: resultType
    }]);
  }

  if (!result) {
    throw graphqlErrors.accessDeniedError(`You cannot perform the '${operation}' operation on the item '${JSON.stringify(inputData)}'.`);
  } // Field level 'item' access control
  // Field level 'item' access control


  const nonBooleans = [];
  const fieldsDenied = [];
  const accessErrors = [];

  for (const fieldKey of Object.keys(inputData)) {
    let result;

    try {
      result = typeof list.fields[fieldKey].access[operation] === 'function' ? await list.fields[fieldKey].access[operation](_objectSpread(_objectSpread({}, args), {}, {
        fieldKey
      })) : access;
    } catch (error) {
      accessErrors.push({
        error,
        tag: `${args.listKey}.${fieldKey}.access.${args.operation}`
      });
      continue;
    }

    if (typeof result !== 'boolean') {
      nonBooleans.push({
        tag: `${args.listKey}.${fieldKey}.access.${args.operation}`,
        returned: typeof result
      });
    } else if (!result) {
      fieldsDenied.push(fieldKey);
    }
  }

  if (accessErrors.length) {
    throw graphqlErrors.extensionError('Access control', accessErrors);
  }

  if (nonBooleans.length) {
    throw graphqlErrors.accessReturnError(nonBooleans);
  }

  if (fieldsDenied.length) {
    throw graphqlErrors.accessDeniedError(`You cannot perform the '${operation}' operation on the item '${JSON.stringify(inputData)}'. You cannot ${operation} the fields ${JSON.stringify(fieldsDenied)}.`);
  }
}

async function runSideEffectOnlyHook(list, hookName, args) {
  // Runs the before/after operation hooks
  let shouldRunFieldLevelHook;

  if (args.operation === 'delete') {
    // Always run field hooks for delete operations
    shouldRunFieldLevelHook = () => true;
  } else {
    // Only run field hooks on if the field was specified in the
    // original input for create and update operations.
    const inputDataKeys = new Set(Object.keys(args.inputData));

    shouldRunFieldLevelHook = fieldKey => inputDataKeys.has(fieldKey);
  } // Field hooks


  const fieldsErrors = [];

  for (const [fieldKey, field] of Object.entries(list.fields)) {
    if (shouldRunFieldLevelHook(fieldKey)) {
      try {
        var _field$hooks$hookName, _field$hooks;

        await ((_field$hooks$hookName = (_field$hooks = field.hooks)[hookName]) === null || _field$hooks$hookName === void 0 ? void 0 : _field$hooks$hookName.call(_field$hooks, _objectSpread({
          fieldKey
        }, args)));
      } catch (error) {
        fieldsErrors.push({
          error,
          tag: `${list.listKey}.${fieldKey}.hooks.${hookName}`
        });
      }
    }
  }

  if (fieldsErrors.length) {
    throw graphqlErrors.extensionError(hookName, fieldsErrors);
  } // List hooks


  try {
    var _list$hooks$hookName, _list$hooks;

    await ((_list$hooks$hookName = (_list$hooks = list.hooks)[hookName]) === null || _list$hooks$hookName === void 0 ? void 0 : _list$hooks$hookName.call(_list$hooks, args));
  } catch (error) {
    throw graphqlErrors.extensionError(hookName, [{
      error,
      tag: `${list.listKey}.hooks.${hookName}`
    }]);
  }
}

async function validateUpdateCreate({
  list,
  hookArgs
}) {
  const messages = [];
  const fieldsErrors = []; // Field validation hooks

  for (const [fieldKey, field] of Object.entries(list.fields)) {
    const addValidationError = msg => messages.push(`${list.listKey}.${fieldKey}: ${msg}`);

    try {
      var _field$hooks$validate, _field$hooks;

      // @ts-ignore
      await ((_field$hooks$validate = (_field$hooks = field.hooks).validateInput) === null || _field$hooks$validate === void 0 ? void 0 : _field$hooks$validate.call(_field$hooks, _objectSpread(_objectSpread({}, hookArgs), {}, {
        addValidationError,
        fieldKey
      })));
    } catch (error) {
      fieldsErrors.push({
        error,
        tag: `${list.listKey}.${fieldKey}.hooks.validateInput`
      });
    }
  }

  if (fieldsErrors.length) {
    throw graphqlErrors.extensionError('validateInput', fieldsErrors);
  } // List validation hooks


  const addValidationError = msg => messages.push(`${list.listKey}: ${msg}`);

  try {
    var _list$hooks$validateI, _list$hooks;

    // @ts-ignore
    await ((_list$hooks$validateI = (_list$hooks = list.hooks).validateInput) === null || _list$hooks$validateI === void 0 ? void 0 : _list$hooks$validateI.call(_list$hooks, _objectSpread(_objectSpread({}, hookArgs), {}, {
      addValidationError
    })));
  } catch (error) {
    throw graphqlErrors.extensionError('validateInput', [{
      error,
      tag: `${list.listKey}.hooks.validateInput`
    }]);
  }

  if (messages.length) {
    throw graphqlErrors.validationFailureError(messages);
  }
}
async function validateDelete({
  list,
  hookArgs
}) {
  const messages = [];
  const fieldsErrors = []; // Field validation

  for (const [fieldKey, field] of Object.entries(list.fields)) {
    const addValidationError = msg => messages.push(`${list.listKey}.${fieldKey}: ${msg}`);

    try {
      var _field$hooks$validate2, _field$hooks2;

      await ((_field$hooks$validate2 = (_field$hooks2 = field.hooks).validateDelete) === null || _field$hooks$validate2 === void 0 ? void 0 : _field$hooks$validate2.call(_field$hooks2, _objectSpread(_objectSpread({}, hookArgs), {}, {
        addValidationError,
        fieldKey
      })));
    } catch (error) {
      fieldsErrors.push({
        error,
        tag: `${list.listKey}.${fieldKey}.hooks.validateDelete`
      });
    }
  }

  if (fieldsErrors.length) {
    throw graphqlErrors.extensionError('validateDelete', fieldsErrors);
  } // List validation


  const addValidationError = msg => messages.push(`${list.listKey}: ${msg}`);

  try {
    var _list$hooks$validateD, _list$hooks2;

    await ((_list$hooks$validateD = (_list$hooks2 = list.hooks).validateDelete) === null || _list$hooks$validateD === void 0 ? void 0 : _list$hooks$validateD.call(_list$hooks2, _objectSpread(_objectSpread({}, hookArgs), {}, {
      addValidationError
    })));
  } catch (error) {
    throw graphqlErrors.extensionError('validateDelete', [{
      error,
      tag: `${list.listKey}.hooks.validateDelete`
    }]);
  }

  if (messages.length) {
    throw graphqlErrors.validationFailureError(messages);
  }
}

async function createSingle({
  data: rawData
}, list, context, operationAccess, writeLimit) {
  // Operation level access control
  if (!operationAccess) {
    throw graphqlErrors.accessDeniedError(`You cannot perform the 'create' operation on the list '${list.listKey}'.`);
  } //  Item access control. Will throw an accessDeniedError if not allowed.


  await applyAccessControlForCreate(list, context, rawData);
  const {
    afterOperation,
    data
  } = await resolveInputForCreateOrUpdate(list, context, rawData, undefined);
  const item = await writeLimit(() => typesForLists.runWithPrisma(context, list, model => model.create({
    data
  })));
  return {
    item,
    afterOperation
  };
}

var _afterOperations = /*#__PURE__*/new WeakMap();

var _context = /*#__PURE__*/new WeakMap();

class NestedMutationState {
  constructor(context) {
    _classPrivateFieldInitSpec(this, _afterOperations, {
      writable: true,
      value: []
    });

    _classPrivateFieldInitSpec(this, _context, {
      writable: true,
      value: void 0
    });

    _classPrivateFieldSet(this, _context, context);
  }

  async create(data, list) {
    const context = _classPrivateFieldGet(this, _context);

    const writeLimit = pLimit__default["default"](1); // Check operation permission to pass into single operation

    const operationAccess = await typesForLists.getOperationAccess(list, context, 'create');
    const {
      item,
      afterOperation
    } = await createSingle({
      data
    }, list, context, operationAccess, writeLimit);

    _classPrivateFieldGet(this, _afterOperations).push(() => afterOperation(item));

    return {
      id: item.id
    };
  }

  async afterOperation() {
    await typesForLists.promiseAllRejectWithAllErrors(_classPrivateFieldGet(this, _afterOperations).map(async x => x()));
  }

}
async function createOne(createInput, list, context) {
  const writeLimit = pLimit__default["default"](1); // Check operation permission to pass into single operation

  const operationAccess = await typesForLists.getOperationAccess(list, context, 'create');
  const {
    item,
    afterOperation
  } = await createSingle(createInput, list, context, operationAccess, writeLimit);
  await afterOperation(item);
  return item;
}
async function createMany(createInputs, list, context, provider) {
  const writeLimit = pLimit__default["default"](provider === 'sqlite' ? 1 : Infinity); // Check operation permission to pass into single operation

  const operationAccess = await typesForLists.getOperationAccess(list, context, 'create');
  return createInputs.data.map(async data => {
    const {
      item,
      afterOperation
    } = await createSingle({
      data
    }, list, context, operationAccess, writeLimit);
    await afterOperation(item);
    return item;
  });
}

async function updateSingle(updateInput, list, context, accessFilters, operationAccess, writeLimit) {
  // Operation level access control
  if (!operationAccess) {
    throw graphqlErrors.accessDeniedError(`You cannot perform the 'update' operation on the list '${list.listKey}'.`);
  }

  const {
    where: uniqueInput,
    data: rawData
  } = updateInput; // Validate and resolve the input filter

  const uniqueWhere = await typesForLists.resolveUniqueWhereInput(uniqueInput, list.fields, context); // Check filter access

  const fieldKey = Object.keys(uniqueWhere)[0];
  await typesForLists.checkFilterOrderAccess([{
    fieldKey,
    list
  }], context, 'filter'); // Filter and Item access control. Will throw an accessDeniedError if not allowed.

  const item = await getAccessControlledItemForUpdate(list, context, uniqueWhere, accessFilters, rawData);
  const {
    afterOperation,
    data
  } = await resolveInputForCreateOrUpdate(list, context, rawData, item);
  const updatedItem = await writeLimit(() => typesForLists.runWithPrisma(context, list, model => model.update({
    where: {
      id: item.id
    },
    data
  })));
  await afterOperation(updatedItem);
  return updatedItem;
}

async function updateOne(updateInput, list, context) {
  const writeLimit = pLimit__default["default"](1); // Check operation permission to pass into single operation

  const operationAccess = await typesForLists.getOperationAccess(list, context, 'update'); // Get list-level access control filters

  const accessFilters = await typesForLists.getAccessFilters(list, context, 'update');
  return updateSingle(updateInput, list, context, accessFilters, operationAccess, writeLimit);
}
async function updateMany({
  data
}, list, context, provider) {
  const writeLimit = pLimit__default["default"](provider === 'sqlite' ? 1 : Infinity); // Check operation permission to pass into single operation

  const operationAccess = await typesForLists.getOperationAccess(list, context, 'update'); // Get list-level access control filters

  const accessFilters = await typesForLists.getAccessFilters(list, context, 'update');
  return data.map(async updateInput => updateSingle(updateInput, list, context, accessFilters, operationAccess, writeLimit));
}

async function getResolvedData(list, hookArgs, nestedMutationState) {
  const {
    context,
    operation
  } = hookArgs; // Start with the original input

  let resolvedData = hookArgs.inputData; // Apply non-relationship field type input resolvers

  const resolverErrors = [];
  resolvedData = Object.fromEntries(await Promise.all(Object.entries(list.fields).map(async ([fieldKey, field]) => {
    var _field$input, _field$input$operatio;

    const inputResolver = (_field$input = field.input) === null || _field$input === void 0 ? void 0 : (_field$input$operatio = _field$input[operation]) === null || _field$input$operatio === void 0 ? void 0 : _field$input$operatio.resolve;
    let input = resolvedData[fieldKey];

    if (inputResolver && field.dbField.kind !== 'relation') {
      try {
        input = await inputResolver(input, context, undefined);
      } catch (error) {
        resolverErrors.push({
          error,
          tag: `${list.listKey}.${fieldKey}`
        });
      }
    }

    return [fieldKey, input];
  })));

  if (resolverErrors.length) {
    throw graphqlErrors.resolverError(resolverErrors);
  } // Apply relationship field type input resolvers


  resolvedData = Object.fromEntries(await typesForLists.promiseAllRejectWithAllErrors(Object.entries(list.fields).map(async ([fieldKey, field]) => {
    var _field$input2, _field$input2$operati;

    const inputResolver = (_field$input2 = field.input) === null || _field$input2 === void 0 ? void 0 : (_field$input2$operati = _field$input2[operation]) === null || _field$input2$operati === void 0 ? void 0 : _field$input2$operati.resolve;
    let input = resolvedData[fieldKey];

    if (inputResolver && field.dbField.kind === 'relation') {
      input = await inputResolver(input, context, // This third argument only applies to relationship fields
      (() => {
        if (input === undefined) {
          // No-op: This is what we want
          return () => undefined;
        }

        if (input === null) {
          // No-op: Should this be UserInputError?
          return () => undefined;
        }

        const target = `${list.listKey}.${fieldKey}<${field.dbField.list}>`;
        const foreignList = list.lists[field.dbField.list];
        let resolver;

        if (field.dbField.mode === 'many') {
          if (operation === 'create') {
            resolver = resolveRelateToManyForCreateInput;
          } else {
            resolver = resolveRelateToManyForUpdateInput;
          }
        } else {
          if (operation === 'create') {
            resolver = resolveRelateToOneForCreateInput;
          } else {
            resolver = resolveRelateToOneForUpdateInput;
          }
        }

        return resolver(nestedMutationState, context, foreignList, target);
      })());
    }

    return [fieldKey, input];
  }))); // Resolve input hooks

  const hookName = 'resolveInput'; // Field hooks

  let _resolvedData = {};
  const fieldsErrors = [];

  for (const [fieldKey, field] of Object.entries(list.fields)) {
    if (field.hooks.resolveInput === undefined) {
      _resolvedData[fieldKey] = resolvedData[fieldKey];
    } else {
      try {
        _resolvedData[fieldKey] = await field.hooks.resolveInput(_objectSpread(_objectSpread({}, hookArgs), {}, {
          resolvedData,
          fieldKey
        }));
      } catch (error) {
        fieldsErrors.push({
          error,
          tag: `${list.listKey}.${fieldKey}.hooks.${hookName}`
        });
      }
    }
  }

  if (fieldsErrors.length) {
    throw graphqlErrors.extensionError(hookName, fieldsErrors);
  }

  resolvedData = _resolvedData; // List hooks

  if (list.hooks.resolveInput) {
    try {
      resolvedData = await list.hooks.resolveInput(_objectSpread(_objectSpread({}, hookArgs), {}, {
        resolvedData
      }));
    } catch (error) {
      throw graphqlErrors.extensionError(hookName, [{
        error,
        tag: `${list.listKey}.hooks.${hookName}`
      }]);
    }
  }

  return resolvedData;
}

async function resolveInputForCreateOrUpdate(list, context, inputData, item) {
  const operation = item === undefined ? 'create' : 'update';
  const nestedMutationState = new NestedMutationState(context);
  const {
    listKey
  } = list;
  const hookArgs = {
    context,
    listKey,
    operation,
    inputData,
    item,
    resolvedData: {}
  }; // Take the original input and resolve all the fields down to what
  // will be saved into the database.

  hookArgs.resolvedData = await getResolvedData(list, hookArgs, nestedMutationState); // Apply all validation checks

  await validateUpdateCreate({
    list,
    hookArgs
  }); // Run beforeOperation hooks

  await runSideEffectOnlyHook(list, 'beforeOperation', hookArgs); // Return the full resolved input (ready for prisma level operation),
  // and the afterOperation hook to be applied

  return {
    data: flattenMultiDbFields(list.fields, hookArgs.resolvedData),
    afterOperation: async updatedItem => {
      await nestedMutationState.afterOperation();
      await runSideEffectOnlyHook(list, 'afterOperation', _objectSpread(_objectSpread({}, hookArgs), {}, {
        item: updatedItem,
        originalItem: item
      }));
    }
  };
}

function flattenMultiDbFields(fields, data) {
  return Object.fromEntries(Object.entries(data).flatMap(([fieldKey, value]) => {
    const {
      dbField
    } = fields[fieldKey];

    if (dbField.kind === 'multi') {
      return Object.entries(value).map(([innerFieldKey, fieldValue]) => {
        return [typesForLists.getDBFieldKeyForFieldOnMultiField(fieldKey, innerFieldKey), fieldValue];
      });
    }

    return [[fieldKey, value]];
  }));
}

async function deleteSingle(uniqueInput, list, context, accessFilters, operationAccess, writeLimit) {
  // Operation level access control
  if (!operationAccess) {
    throw graphqlErrors.accessDeniedError(`You cannot perform the 'delete' operation on the list '${list.listKey}'.`);
  } // Validate and resolve the input filter


  const uniqueWhere = await typesForLists.resolveUniqueWhereInput(uniqueInput, list.fields, context); // Check filter access

  const fieldKey = Object.keys(uniqueWhere)[0];
  await typesForLists.checkFilterOrderAccess([{
    fieldKey,
    list
  }], context, 'filter'); // Filter and Item access control. Will throw an accessDeniedError if not allowed.

  const item = await getAccessControlledItemForDelete(list, context, uniqueWhere, accessFilters);
  const hookArgs = {
    operation: 'delete',
    listKey: list.listKey,
    context,
    item,
    resolvedData: undefined,
    inputData: undefined
  }; // Apply all validation checks

  await validateDelete({
    list,
    hookArgs
  }); // Before operation

  await runSideEffectOnlyHook(list, 'beforeOperation', hookArgs);
  const newItem = await writeLimit(() => typesForLists.runWithPrisma(context, list, model => model.delete({
    where: {
      id: item.id
    }
  })));
  await runSideEffectOnlyHook(list, 'afterOperation', _objectSpread(_objectSpread({}, hookArgs), {}, {
    item: undefined,
    originalItem: item
  }));
  return newItem;
}

async function deleteMany(uniqueInputs, list, context, provider) {
  const writeLimit = pLimit__default["default"](provider === 'sqlite' ? 1 : Infinity); // Check operation permission to pass into single operation

  const operationAccess = await typesForLists.getOperationAccess(list, context, 'delete'); // Check filter permission to pass into single operation

  const accessFilters = await typesForLists.getAccessFilters(list, context, 'delete');
  return uniqueInputs.map(async uniqueInput => deleteSingle(uniqueInput, list, context, accessFilters, operationAccess, writeLimit));
}
async function deleteOne(uniqueInput, list, context) {
  // Check operation permission to pass into single operation
  const operationAccess = await typesForLists.getOperationAccess(list, context, 'delete'); // Check filter permission to pass into single operation

  const accessFilters = await typesForLists.getAccessFilters(list, context, 'delete');
  return deleteSingle(uniqueInput, list, context, accessFilters, operationAccess, pLimit__default["default"](1));
}

// Basically, old keystone uses Promise.allSettled and then after that maps that into promises that resolve and reject,
// whereas the new stuff is just like "here are some promises" with no guarantees about the order they will be settled in.
// That doesn't matter when they all resolve successfully because the order they resolve successfully in
// doesn't affect anything, If some reject though, the order that they reject in will be the order in the errors array
// and some of our tests rely on the order of the graphql errors array. They shouldn't, but they do.

function promisesButSettledWhenAllSettledAndInOrder(promises) {
  const resultsPromise = Promise.allSettled(promises);
  return promises.map(async (_, i) => {
    const result = (await resultsPromise)[i];
    return result.status === 'fulfilled' ? Promise.resolve(result.value) : Promise.reject(result.reason);
  });
}

function getMutationsForList(list, provider) {
  const names = core.getGqlNames(list);
  const createOne$1 = apiWithContext.field({
    type: list.types.output,
    args: {
      data: apiWithoutContext.arg({
        type: apiWithoutContext.nonNull(list.types.create)
      })
    },

    resolve(_rootVal, {
      data
    }, context) {
      return createOne({
        data
      }, list, context);
    }

  });
  const createMany$1 = apiWithContext.field({
    type: apiWithoutContext.list(list.types.output),
    args: {
      data: apiWithoutContext.arg({
        type: apiWithoutContext.nonNull(apiWithoutContext.list(apiWithoutContext.nonNull(list.types.create)))
      })
    },

    async resolve(_rootVal, args, context) {
      return promisesButSettledWhenAllSettledAndInOrder(await createMany(args, list, context, provider));
    }

  });
  const updateOne$1 = apiWithContext.field({
    type: list.types.output,
    args: {
      where: apiWithoutContext.arg({
        type: apiWithoutContext.nonNull(list.types.uniqueWhere)
      }),
      data: apiWithoutContext.arg({
        type: apiWithoutContext.nonNull(list.types.update)
      })
    },

    resolve(_rootVal, args, context) {
      return updateOne(args, list, context);
    }

  });
  const updateManyInput = apiWithoutContext.inputObject({
    name: names.updateManyInputName,
    fields: {
      where: apiWithoutContext.arg({
        type: apiWithoutContext.nonNull(list.types.uniqueWhere)
      }),
      data: apiWithoutContext.arg({
        type: apiWithoutContext.nonNull(list.types.update)
      })
    }
  });
  const updateMany$1 = apiWithContext.field({
    type: apiWithoutContext.list(list.types.output),
    args: {
      data: apiWithoutContext.arg({
        type: apiWithoutContext.nonNull(apiWithoutContext.list(apiWithoutContext.nonNull(updateManyInput)))
      })
    },

    async resolve(_rootVal, args, context) {
      return promisesButSettledWhenAllSettledAndInOrder(await updateMany(args, list, context, provider));
    }

  });
  const deleteOne$1 = apiWithContext.field({
    type: list.types.output,
    args: {
      where: apiWithoutContext.arg({
        type: apiWithoutContext.nonNull(list.types.uniqueWhere)
      })
    },

    resolve(rootVal, {
      where
    }, context) {
      return deleteOne(where, list, context);
    }

  });
  const deleteMany$1 = apiWithContext.field({
    type: apiWithoutContext.list(list.types.output),
    args: {
      where: apiWithoutContext.arg({
        type: apiWithoutContext.nonNull(apiWithoutContext.list(apiWithoutContext.nonNull(list.types.uniqueWhere)))
      })
    },

    async resolve(rootVal, {
      where
    }, context) {
      return promisesButSettledWhenAllSettledAndInOrder(await deleteMany(where, list, context, provider));
    }

  });
  return {
    mutations: _objectSpread(_objectSpread(_objectSpread({}, list.graphql.isEnabled.create && {
      [names.createMutationName]: createOne$1,
      [names.createManyMutationName]: createMany$1
    }), list.graphql.isEnabled.update && {
      [names.updateMutationName]: updateOne$1,
      [names.updateManyMutationName]: updateMany$1
    }), list.graphql.isEnabled.delete && {
      [names.deleteMutationName]: deleteOne$1,
      [names.deleteManyMutationName]: deleteMany$1
    }),
    updateManyInput
  };
}

function getQueriesForList(list) {
  if (!list.graphql.isEnabled.query) return {};
  const names = core.getGqlNames(list);
  const findOne = apiWithContext.field({
    type: list.types.output,
    args: {
      where: apiWithoutContext.arg({
        type: apiWithoutContext.nonNull(list.types.uniqueWhere)
      })
    },

    async resolve(_rootVal, args, context) {
      return typesForLists.findOne(args, list, context);
    }

  });
  const findMany = apiWithContext.field({
    type: apiWithoutContext.list(apiWithoutContext.nonNull(list.types.output)),
    args: list.types.findManyArgs,

    async resolve(_rootVal, args, context, info) {
      return typesForLists.findMany(args, list, context, info);
    }

  });
  const countQuery = apiWithContext.field({
    type: apiWithoutContext.Int,
    args: {
      where: apiWithoutContext.arg({
        type: apiWithoutContext.nonNull(list.types.where),
        defaultValue: {}
      })
    },

    async resolve(_rootVal, args, context, info) {
      return typesForLists.count(args, list, context, info);
    }

  });
  return {
    [names.listQueryName]: findMany,
    [names.itemQueryName]: findOne,
    [names.listQueryCountName]: countQuery
  };
}

function getGraphQLSchema(lists, provider) {
  const query = apiWithContext.object()({
    name: 'Query',
    fields: Object.assign({}, ...Object.values(lists).map(list => getQueriesForList(list)))
  });
  const updateManyByList = {};
  const mutation = apiWithContext.object()({
    name: 'Mutation',
    fields: Object.assign({}, ...Object.values(lists).map(list => {
      const {
        mutations,
        updateManyInput
      } = getMutationsForList(list, provider);
      updateManyByList[list.listKey] = updateManyInput;
      return mutations;
    }))
  });
  const graphQLSchema = new graphql$1.GraphQLSchema({
    query: query.graphQLType,
    mutation: mutation.graphQLType,
    types: collectTypes(lists, updateManyByList)
  });
  return graphQLSchema;
}

function collectTypes(lists, updateManyByList) {
  const collectedTypes = [];

  for (const list of Object.values(lists)) {
    const {
      isEnabled
    } = list.graphql;
    if (!isEnabled.type) continue; // adding all of these types explicitly isn't strictly necessary but we do it to create a certain order in the schema

    collectedTypes.push(list.types.output.graphQLType);

    if (isEnabled.query || isEnabled.update || isEnabled.delete) {
      collectedTypes.push(list.types.uniqueWhere.graphQLType);
    }

    if (isEnabled.query) {
      for (const field of Object.values(list.fields)) {
        if (isEnabled.query && field.graphql.isEnabled.read && field.unreferencedConcreteInterfaceImplementations) {
          // this _IS_ actually necessary since they aren't implicitly referenced by other types, unlike the types above
          collectedTypes.push(...field.unreferencedConcreteInterfaceImplementations.map(x => x.graphQLType));
        }
      }

      collectedTypes.push(list.types.where.graphQLType);
      collectedTypes.push(list.types.orderBy.graphQLType);
    }

    if (isEnabled.update) {
      collectedTypes.push(list.types.update.graphQLType);
      collectedTypes.push(updateManyByList[list.listKey].graphQLType);
    }

    if (isEnabled.create) {
      collectedTypes.push(list.types.create.graphQLType);
    }
  } // this is not necessary, just about ordering


  collectedTypes.push(graphqlTsSchema.JSON.graphQLType);
  return collectedTypes;
}

function createGraphQLSchema(config, lists, adminMeta) {
  // Start with the core keystone graphQL schema
  let graphQLSchema = getGraphQLSchema(lists, config.db.provider); // Merge in the user defined graphQL API

  if (config.extendGraphqlSchema) {
    graphQLSchema = config.extendGraphqlSchema(graphQLSchema);
  } // Merge in session graphQL API


  if (config.session) {
    graphQLSchema = session_dist_keystone.sessionSchema(graphQLSchema);
  } // Merge in the admin-meta graphQL API


  graphQLSchema = getAdminMetaSchema({
    adminMeta,
    config,
    graphQLSchema,
    lists
  });
  return graphQLSchema;
}

function getRootTypeName(type) {
  if (type instanceof graphql$1.GraphQLNonNull) {
    return getRootTypeName(type.ofType);
  }

  if (type instanceof graphql$1.GraphQLList) {
    return getRootTypeName(type.ofType);
  }

  return type.name;
}

function executeGraphQLFieldWithSelection(schema, operation, fieldName) {
  const rootType = operation === 'mutation' ? schema.getMutationType() : schema.getQueryType();
  const field = rootType.getFields()[fieldName];

  if (field === undefined) {
    return () => {
      throw new Error('You do not have access to this resource');
    };
  }

  const {
    argumentNodes,
    variableDefinitions
  } = typesForLists.getVariablesForGraphQLField(field);
  const rootName = getRootTypeName(field.type);
  return async (args, query, context) => {
    var _result$errors;

    const selectionSet = graphql$1.parse(`fragment x on ${rootName} {${query}}`).definitions[0].selectionSet;
    const document = {
      kind: 'Document',
      definitions: [{
        kind: 'OperationDefinition',
        operation,
        selectionSet: {
          kind: 'SelectionSet',
          selections: [{
            kind: 'Field',
            name: {
              kind: 'Name',
              value: field.name
            },
            arguments: argumentNodes,
            selectionSet: selectionSet
          }]
        },
        variableDefinitions
      }]
    };
    const validationErrors = graphql$1.validate(schema, document);

    if (validationErrors.length > 0) {
      throw validationErrors[0];
    }

    const result = await graphql$1.execute({
      schema,
      document,
      contextValue: context,
      variableValues: Object.fromEntries( // GraphQL for some reason decides to make undefined values in args
      // skip defaulting for some reason
      // this ofc doesn't technically fully fix it (bc nested things)
      // but for the cases where we care, it does
      Object.entries(args).filter(([, val]) => val !== undefined)),
      rootValue: {}
    });

    if ((_result$errors = result.errors) !== null && _result$errors !== void 0 && _result$errors.length) {
      throw result.errors[0];
    }

    return result.data[field.name];
  };
}

const _excluded = ["query", "resolveFields"];
// (i mean it's not really any more incorrect than TS is generally is but let's ignore that)

const objectEntriesButUsingKeyof = Object.entries;
function getDbAPIFactory(gqlNames, schema) {
  const queryFields = schema.getQueryType().getFields();
  const mutationFields = schema.getMutationType().getFields();

  const f = field => {
    if (field === undefined) {
      return () => {
        throw new Error('You do not have access to this resource');
      };
    }

    return typesForLists.executeGraphQLFieldToRootVal(field);
  };

  const api = {
    findOne: f(queryFields[gqlNames.itemQueryName]),
    findMany: f(queryFields[gqlNames.listQueryName]),
    count: f(queryFields[gqlNames.listQueryCountName]),
    createOne: f(mutationFields[gqlNames.createMutationName]),
    createMany: f(mutationFields[gqlNames.createManyMutationName]),
    updateOne: f(mutationFields[gqlNames.updateMutationName]),
    updateMany: f(mutationFields[gqlNames.updateManyMutationName]),
    deleteOne: f(mutationFields[gqlNames.deleteMutationName]),
    deleteMany: f(mutationFields[gqlNames.deleteManyMutationName])
  };
  return context => Object.fromEntries(objectEntriesButUsingKeyof(api).map(([key, impl]) => [key, args => impl(args, context)]));
}

function defaultQueryParam(query, resolveFields) {
  if (query !== undefined && resolveFields !== undefined) {
    throw new Error('query and resolveFields cannot both be passed to an Items API query');
  }

  if (query !== undefined) return query;
  if (resolveFields !== undefined) return resolveFields;
  return 'id';
}
/* NOTE
 *
 * The `resolveFields` param has been deprecated in favor of `query` (when selecting fields to
 * query) or the new dbAPI which is available via `context.db.{List}`, which replaces
 * the previous `resolveFields: false` behaviour.
 *
 * We'll be removing the option to use `resolveFields` entirely in a future release.
 */


function itemAPIForList(listKey, context, dbAPI) {
  const f = (operation, field, dbAPIVersionOfAPI) => {
    const exec = executeGraphQLFieldWithSelection(context.graphql.schema, operation, field);
    return (_ref = {}) => {
      let {
        query,
        resolveFields
      } = _ref,
          args = _objectWithoutProperties(_ref, _excluded);

      const returnFields = defaultQueryParam(query, resolveFields);

      if (returnFields) {
        return exec(args, returnFields, context);
      } else {
        return dbAPIVersionOfAPI(args);
      }
    };
  };

  const gqlNames = context.gqlNames(listKey);
  return {
    findOne: f('query', gqlNames.itemQueryName, dbAPI.findOne),
    findMany: f('query', gqlNames.listQueryName, dbAPI.findMany),

    async count({
      where = {}
    } = {}) {
      const {
        listQueryCountName,
        whereInputName
      } = context.gqlNames(listKey);
      const query = `query ($where: ${whereInputName}!) { count: ${listQueryCountName}(where: $where)  }`;
      const response = await context.graphql.run({
        query,
        variables: {
          where
        }
      });
      return response.count;
    },

    createOne: f('mutation', gqlNames.createMutationName, dbAPI.createOne),
    createMany: f('mutation', gqlNames.createManyMutationName, dbAPI.createMany),
    updateOne: f('mutation', gqlNames.updateMutationName, dbAPI.updateOne),
    updateMany: f('mutation', gqlNames.updateManyMutationName, dbAPI.updateMany),
    deleteOne: f('mutation', gqlNames.deleteMutationName, dbAPI.deleteOne),
    deleteMany: f('mutation', gqlNames.deleteManyMutationName, dbAPI.deleteMany)
  };
}

const getImagesSubdomain = ({
  apiKey
}) => {
  const [, domain] = apiKey.split('__IMAGES_DOMAIN__');

  if (!domain) {
    throw new Error('Your API key is outdated, please regenerate it and add the new key to your Keystone config');
  }

  return domain;
};

const getS3Bucket = async ({
  apiKey,
  graphqlApiEndpoint
}) => {
  const response = await fetch__default["default"](graphqlApiEndpoint, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({
      query: `
        query($apiKey:String) {
          allAmazonS3Buckets(where: { project: { apiKey: { apiKey: $apiKey } } }) {
            bucketName,
            prefix,
            region
          }
        }
      `,
      variables: {
        apiKey
      }
    })
  });
  const json = await response.json();
  const {
    data
  } = json;
  const {
    allAmazonS3Buckets
  } = data;
  return allAmazonS3Buckets[0];
};

const uploadAsset = async ({
  apiKey,
  filename,
  inputFieldName,
  stream,
  apiRoute,
  restApiEndpoint
}) => {
  const form = new FormData__default["default"]();
  form.append(inputFieldName, stream, filename);
  const response = await fetch__default["default"](`${restApiEndpoint}/${apiRoute}`, {
    method: 'POST',
    body: form,
    headers: {
      Authorization: `Bearer ${apiKey}`
    }
  });
  return await response.json();
};

const buildKeystoneCloudImageSrc = async ({
  apiKey,
  filename,
  imagesDomain
}) => {
  const imagesSubdomain = getImagesSubdomain({
    apiKey
  });
  return `http://${imagesSubdomain}.${imagesDomain}/${filename}`;
};
const buildKeystoneCloudFileSrc = async ({
  apiKey,
  graphqlApiEndpoint,
  filename
}) => {
  const {
    bucketName,
    prefix,
    region
  } = await getS3Bucket({
    apiKey,
    graphqlApiEndpoint
  });
  return `https://${bucketName}.s3.${region}.amazonaws.com/${prefix}/${filename}`;
};
const getImageMetadataFromKeystoneCloud = async ({
  apiKey,
  filename,
  restApiEndpoint
}) => {
  const response = await fetch__default["default"](`${restApiEndpoint}/images/${filename}`, {
    headers: {
      Authorization: `Bearer ${apiKey}`
    }
  });
  return await response.json();
};
const getFileFromKeystoneCloud = async ({
  apiKey,
  filename,
  restApiEndpoint
}) => {
  const response = await fetch__default["default"](`${restApiEndpoint}/files/${filename}`, {
    headers: {
      Authorization: `Bearer ${apiKey}`
    }
  });
  return await response.json();
};
const uploadImageToKeystoneCloud = async ({
  apiKey,
  stream,
  filename,
  restApiEndpoint
}) => uploadAsset({
  apiKey,
  stream,
  filename,
  restApiEndpoint,
  inputFieldName: 'image',
  apiRoute: 'images'
});
const uploadFileToKeystoneCloud = async ({
  apiKey,
  stream,
  filename,
  restApiEndpoint
}) => uploadAsset({
  apiKey,
  stream,
  filename,
  restApiEndpoint,
  inputFieldName: 'file',
  apiRoute: 'files'
});

const DEFAULT_BASE_URL$1 = '/images';
const DEFAULT_STORAGE_PATH$1 = './public/images';

const getImageMetadataFromBuffer = async buffer => {
  const filesize = buffer.length;
  const fileType = fromBuffer__default["default"](buffer);

  if (!fileType) {
    throw new Error('File type not found');
  }

  if (fileType.ext !== 'jpg' && fileType.ext !== 'png' && fileType.ext !== 'webp' && fileType.ext !== 'gif') {
    throw new Error(`${fileType.ext} is not a supported image type`);
  }

  const extension = fileType.ext;
  const {
    height,
    width
  } = imageSize__default["default"](buffer);

  if (width === undefined || height === undefined) {
    throw new Error('Height and width could not be found for image');
  }

  return {
    width,
    height,
    filesize,
    extension
  };
};

function createImagesContext(config) {
  if (!config.images) {
    return;
  }

  const {
    images,
    experimental
  } = config;
  const {
    baseUrl = DEFAULT_BASE_URL$1,
    storagePath = DEFAULT_STORAGE_PATH$1
  } = images.local || {};
  const {
    apiKey = '',
    imagesDomain = '',
    restApiEndpoint = ''
  } = (experimental === null || experimental === void 0 ? void 0 : experimental.keystoneCloud) || {};

  if (images.upload === 'local') {
    fs__default["default"].mkdirSync(storagePath, {
      recursive: true
    });
  }

  return {
    getSrc: async (mode, id, extension) => {
      const filename = `${id}.${extension}`;

      if (mode === 'keystone-cloud') {
        return await buildKeystoneCloudImageSrc({
          apiKey,
          imagesDomain,
          filename
        });
      }

      return `${baseUrl}/${filename}`;
    },
    getDataFromRef: async ref => {
      const imageRef = fields_types_image_utils_dist_keystone.parseImageRef(ref);

      if (!imageRef) {
        throw new Error('Invalid image reference');
      }

      const {
        mode
      } = imageRef;

      if (mode === 'keystone-cloud') {
        const {
          id,
          extension
        } = imageRef;
        const filename = `${id}.${extension}`;
        const metadata = await getImageMetadataFromKeystoneCloud({
          filename,
          apiKey,
          restApiEndpoint
        });
        return _objectSpread(_objectSpread({}, imageRef), metadata);
      }

      const buffer = await fs__default["default"].readFile(Path__namespace["default"].join(storagePath, `${imageRef.id}.${imageRef.extension}`));
      const metadata = await getImageMetadataFromBuffer(buffer);
      return _objectSpread(_objectSpread({}, imageRef), metadata);
    },
    getDataFromStream: async stream => {
      const {
        upload: mode
      } = images;
      const id = uuid.v4();

      if (mode === 'keystone-cloud') {
        const metadata = await uploadImageToKeystoneCloud({
          apiKey,
          stream,
          restApiEndpoint,
          filename: id
        });
        return _objectSpread({
          mode,
          id
        }, metadata);
      }

      const chunks = [];

      for await (let chunk of stream) {
        chunks.push(chunk);
      }

      const buffer = Buffer.concat(chunks);
      const metadata = await getImageMetadataFromBuffer(buffer);
      await fs__default["default"].writeFile(Path__namespace["default"].join(storagePath, `${id}.${metadata.extension}`), buffer);
      return _objectSpread({
        mode,
        id
      }, metadata);
    }
  };
}

const DEFAULT_BASE_URL = '/files';
const DEFAULT_STORAGE_PATH = './public/files';

const defaultTransformer = str => slugify__default["default"](str);

const generateSafeFilename = (filename, transformFilename = defaultTransformer) => {
  // Appends a UUID to the filename so that people can't brute-force guess stored filenames
  //
  // This regex lazily matches for any characters that aren't a new line
  // it then optionally matches the last instance of a "." symbol
  // followed by any alphabetical character before the end of the string
  const [, name, ext] = filename.match(/^([^:\n].*?)(\.[A-Za-z]+)?$/);
  const id = crypto__default["default"].randomBytes(24).toString('base64').replace(/[^a-zA-Z0-9]/g, '').slice(12); // console.log(id, id.length, id.slice(12).length);

  const urlSafeName = filenamify__default["default"](transformFilename(name), {
    maxLength: 100 - id.length,
    replacement: '-'
  });

  if (ext) {
    return `${urlSafeName}-${id}${ext}`;
  }

  return `${urlSafeName}-${id}`;
};

function createFilesContext(config) {
  if (!config.files) {
    return;
  }

  const {
    files,
    experimental
  } = config;
  const {
    baseUrl = DEFAULT_BASE_URL,
    storagePath = DEFAULT_STORAGE_PATH
  } = files.local || {};
  const {
    apiKey = '',
    graphqlApiEndpoint = '',
    restApiEndpoint = ''
  } = (experimental === null || experimental === void 0 ? void 0 : experimental.keystoneCloud) || {};

  if (files.upload === 'local') {
    fs__default["default"].mkdirSync(storagePath, {
      recursive: true
    });
  }

  return {
    getSrc: async (mode, filename) => {
      if (mode === 'keystone-cloud') {
        return await buildKeystoneCloudFileSrc({
          apiKey,
          graphqlApiEndpoint,
          filename
        });
      }

      return `${baseUrl}/${filename}`;
    },
    getDataFromRef: async ref => {
      const fileRef = fields_types_file_utils_dist_keystone.parseFileRef(ref);

      if (!fileRef) {
        throw new Error('Invalid file reference');
      }

      const {
        mode,
        filename
      } = fileRef;

      if (mode === 'keystone-cloud') {
        const {
          filesize
        } = await getFileFromKeystoneCloud({
          apiKey,
          filename,
          restApiEndpoint
        });
        return _objectSpread({
          filesize
        }, fileRef);
      }

      const {
        size: filesize
      } = await fs__default["default"].stat(Path__namespace["default"].join(storagePath, fileRef.filename));
      return _objectSpread({
        filesize
      }, fileRef);
    },
    getDataFromStream: async (stream$1, originalFilename) => {
      const {
        upload: mode
      } = files;
      const filename = generateSafeFilename(originalFilename, files.transformFilename);

      if (mode === 'keystone-cloud') {
        const {
          filesize
        } = await uploadFileToKeystoneCloud({
          apiKey,
          stream: stream$1,
          filename,
          restApiEndpoint
        });
        return {
          mode,
          filesize,
          filename
        };
      }

      const writeStream = fs__default["default"].createWriteStream(Path__namespace["default"].join(storagePath, filename));
      const pipeStreams = new Promise((resolve, reject) => {
        stream.pipeline(stream$1, writeStream, err => {
          if (err) {
            reject(err);
          } else {
            resolve();
          }
        });
      });

      try {
        await pipeStreams;
        const {
          size: filesize
        } = await fs__default["default"].stat(Path__namespace["default"].join(storagePath, filename));
        return {
          mode,
          filesize,
          filename
        };
      } catch (e) {
        await fs__default["default"].remove(Path__namespace["default"].join(storagePath, filename));
        throw e;
      }
    }
  };
}

function makeCreateContext({
  graphQLSchema,
  sudoGraphQLSchema,
  prismaClient,
  gqlNamesByList,
  config,
  lists
}) {
  const images = createImagesContext(config);
  const files = createFilesContext(config); // We precompute these helpers here rather than every time createContext is called
  // because they involve creating a new GraphQLSchema, creating a GraphQL document AST(programmatically, not by parsing) and validating the
  // note this isn't as big of an optimisation as you would imagine(at least in comparison with the rest of the system),
  // the regular non-db lists api does more expensive things on every call
  // like parsing the generated GraphQL document, and validating it against the schema on _every_ call
  // is that really that bad? no not really. this has just been more optimised because the cost of what it's
  // doing is more obvious(even though in reality it's much smaller than the alternative)

  const publicDbApiFactories = {};

  for (const [listKey, gqlNames] of Object.entries(gqlNamesByList)) {
    publicDbApiFactories[listKey] = getDbAPIFactory(gqlNames, graphQLSchema);
  }

  const sudoDbApiFactories = {};

  for (const [listKey, gqlNames] of Object.entries(gqlNamesByList)) {
    sudoDbApiFactories[listKey] = getDbAPIFactory(gqlNames, sudoGraphQLSchema);
  }

  const createContext = ({
    sessionContext,
    sudo = false,
    req
  } = {}) => {
    var _config$graphql$query, _config$graphql, _config$graphql$query2, _config$experimental;

    const schema = sudo ? sudoGraphQLSchema : graphQLSchema;

    const rawGraphQL = ({
      query,
      variables
    }) => {
      const source = typeof query === 'string' ? query : graphql$1.print(query);
      return Promise.resolve(graphql$1.graphql({
        schema,
        source,
        contextValue: contextToReturn,
        variableValues: variables
      }));
    };

    const runGraphQL = async ({
      query,
      variables
    }) => {
      var _result$errors;

      let result = await rawGraphQL({
        query,
        variables
      });

      if ((_result$errors = result.errors) !== null && _result$errors !== void 0 && _result$errors.length) {
        throw result.errors[0];
      }

      return result.data;
    };

    const dbAPI = {};
    const itemAPI = {};

    const contextToReturn = _objectSpread(_objectSpread({
      db: dbAPI,
      query: itemAPI,
      totalResults: 0,
      prisma: prismaClient,
      graphql: {
        raw: rawGraphQL,
        run: runGraphQL,
        schema
      },
      maxTotalResults: (_config$graphql$query = (_config$graphql = config.graphql) === null || _config$graphql === void 0 ? void 0 : (_config$graphql$query2 = _config$graphql.queryLimits) === null || _config$graphql$query2 === void 0 ? void 0 : _config$graphql$query2.maxTotalResults) !== null && _config$graphql$query !== void 0 ? _config$graphql$query : Infinity,
      sudo: () => createContext({
        sessionContext,
        sudo: true,
        req
      }),
      exitSudo: () => createContext({
        sessionContext,
        sudo: false,
        req
      }),
      withSession: session => createContext({
        sessionContext: _objectSpread(_objectSpread({}, sessionContext), {}, {
          session
        }),
        sudo,
        req
      }),
      req
    }, sessionContext), {}, {
      // Note: This field lets us use the server-side-graphql-client library.
      // We may want to remove it once the updated itemAPI w/ query is available.
      gqlNames: listKey => gqlNamesByList[listKey],
      images,
      files
    });

    if ((_config$experimental = config.experimental) !== null && _config$experimental !== void 0 && _config$experimental.contextInitialisedLists) {
      contextToReturn.experimental = {
        initialisedLists: lists
      };
    }

    const dbAPIFactories = sudo ? sudoDbApiFactories : publicDbApiFactories;

    for (const listKey of Object.keys(gqlNamesByList)) {
      dbAPI[listKey] = dbAPIFactories[listKey](contextToReturn);
      itemAPI[listKey] = itemAPIForList(listKey, contextToReturn, dbAPI[listKey]);
    }

    return contextToReturn;
  };

  return createContext;
}

function getSudoGraphQLSchema(config, provider) {
  // This function creates a GraphQLSchema based on a modified version of the provided config.
  // The modifications are:
  //  * All list level access control is disabled
  //  * All field level access control is disabled
  //  * All graphql.omit configuration is disabled
  //  * All fields are explicitly made filterable and orderable
  //
  // These changes result in a schema without any restrictions on the CRUD
  // operations that can be run.
  //
  // The resulting schema is used as the GraphQL schema when calling `context.sudo()`.
  const transformedConfig = _objectSpread(_objectSpread({}, config), {}, {
    lists: Object.fromEntries(Object.entries(config.lists).map(([listKey, list]) => {
      return [listKey, _objectSpread(_objectSpread({}, list), {}, {
        access: {
          operation: {},
          item: {},
          filter: {}
        },
        graphql: _objectSpread(_objectSpread({}, list.graphql || {}), {}, {
          omit: []
        }),
        fields: Object.fromEntries(Object.entries(list.fields).map(([fieldKey, field]) => {
          return [fieldKey, data => {
            const f = field(data);
            return _objectSpread(_objectSpread({}, f), {}, {
              access: () => true,
              isFilterable: true,
              isOrderable: true,
              graphql: _objectSpread(_objectSpread({}, f.graphql || {}), {}, {
                omit: []
              })
            });
          }];
        }))
      })];
    }))
  });

  const lists = typesForLists.initialiseLists(transformedConfig.lists, provider);
  const adminMeta = createAdminMeta(transformedConfig, lists);
  return createGraphQLSchema(transformedConfig, lists, adminMeta);
}

function createSystem(config) {
  const lists = typesForLists.initialiseLists(config.lists, config.db.provider);
  const adminMeta = createAdminMeta(config, lists);
  const graphQLSchema = createGraphQLSchema(config, lists, adminMeta);
  const sudoGraphQLSchema = getSudoGraphQLSchema(config, config.db.provider);
  return {
    graphQLSchema,
    adminMeta,
    getKeystone: PrismaClient => {
      const prismaClient = new PrismaClient({
        log: config.db.enableLogging && ['query'],
        datasources: {
          [config.db.provider]: {
            url: config.db.url
          }
        }
      });
      prismaClient.$on('beforeExit', async () => {
        // Prisma is failing to properly clean up its child processes
        // https://github.com/keystonejs/keystone/issues/5477
        // We explicitly send a SIGINT signal to the prisma child process on exit
        // to ensure that the process is cleaned up appropriately.
        prismaClient._engine.child.kill('SIGINT');
      });
      const createContext = makeCreateContext({
        graphQLSchema,
        sudoGraphQLSchema,
        config,
        prismaClient,
        gqlNamesByList: Object.fromEntries(Object.entries(lists).map(([listKey, list]) => [listKey, core.getGqlNames(list)])),
        lists
      });
      return {
        async connect() {
          var _config$db$onConnect, _config$db;

          await prismaClient.$connect();
          const context = createContext({
            sudo: true
          });
          await ((_config$db$onConnect = (_config$db = config.db).onConnect) === null || _config$db$onConnect === void 0 ? void 0 : _config$db$onConnect.call(_config$db, context));
        },

        async disconnect() {
          await prismaClient.$disconnect();
        },

        createContext
      };
    }
  };
}

const views = Path__namespace["default"].join(packagePath.packagePath, '___internal-do-not-use-will-break-in-patch/admin-ui/id-field-view');
const idParsers = {
  autoincrement(val) {
    if (val === null) {
      throw graphqlErrors.userInputError('Only an integer can be passed to id filters');
    }

    const parsed = parseInt(val);

    if (Number.isInteger(parsed)) {
      return parsed;
    }

    throw graphqlErrors.userInputError('Only an integer can be passed to id filters');
  },

  cuid(val) {
    // isCuid is just "it's a string and it starts with c"
    // https://github.com/ericelliott/cuid/blob/215b27bdb78d3400d4225a4eeecb3b71891a5f6f/index.js#L69-L73
    if (typeof val === 'string' && cuid.isCuid(val)) {
      return val;
    }

    throw graphqlErrors.userInputError('Only a cuid can be passed to id filters');
  },

  uuid(val) {
    if (typeof val === 'string' && uuid.validate(val)) {
      return val.toLowerCase();
    }

    throw graphqlErrors.userInputError('Only a uuid can be passed to id filters');
  }

};
const nonCircularFields = {
  equals: apiWithoutContext.arg({
    type: apiWithoutContext.ID
  }),
  in: apiWithoutContext.arg({
    type: apiWithoutContext.list(apiWithoutContext.nonNull(apiWithoutContext.ID))
  }),
  notIn: apiWithoutContext.arg({
    type: apiWithoutContext.list(apiWithoutContext.nonNull(apiWithoutContext.ID))
  }),
  lt: apiWithoutContext.arg({
    type: apiWithoutContext.ID
  }),
  lte: apiWithoutContext.arg({
    type: apiWithoutContext.ID
  }),
  gt: apiWithoutContext.arg({
    type: apiWithoutContext.ID
  }),
  gte: apiWithoutContext.arg({
    type: apiWithoutContext.ID
  })
};
const IDFilter = apiWithoutContext.inputObject({
  name: 'IDFilter',
  fields: () => _objectSpread(_objectSpread({}, nonCircularFields), {}, {
    not: apiWithoutContext.arg({
      type: IDFilter
    })
  })
});
const filterArg = apiWithoutContext.arg({
  type: IDFilter
});

function resolveVal(input, kind) {
  if (input === null) {
    throw graphqlErrors.userInputError('id filter cannot be null');
  }

  const idParser = idParsers[kind];
  const obj = {};

  for (const key of ['equals', 'gt', 'gte', 'lt', 'lte']) {
    const val = input[key];

    if (val !== undefined) {
      const parsed = idParser(val);
      obj[key] = parsed;
    }
  }

  for (const key of ['in', 'notIn']) {
    const val = input[key];

    if (val !== undefined) {
      if (val === null) {
        throw graphqlErrors.userInputError(`${key} id filter cannot be null`);
      }

      obj[key] = val.map(x => idParser(x));
    }
  }

  if (input.not !== undefined) {
    obj.not = resolveVal(input.not, kind);
  }

  return obj;
}

const idFieldType = config => meta => {
  const parseVal = idParsers[config.kind];
  return sqlite.fieldType({
    kind: 'scalar',
    mode: 'required',
    scalar: config.kind === 'autoincrement' ? 'Int' : 'String',
    nativeType: meta.provider === 'postgresql' && config.kind === 'uuid' ? 'Uuid' : undefined,
    default: {
      kind: config.kind
    }
  })(_objectSpread(_objectSpread({}, config), {}, {
    // The ID field is always filterable and orderable.
    isFilterable: true,
    isOrderable: true,
    input: {
      where: {
        arg: filterArg,

        resolve(val) {
          return resolveVal(val, config.kind);
        }

      },
      uniqueWhere: {
        arg: apiWithoutContext.arg({
          type: apiWithoutContext.ID
        }),
        resolve: parseVal
      },
      orderBy: {
        arg: apiWithoutContext.arg({
          type: sqlite.orderDirectionEnum
        })
      }
    },
    output: apiWithContext.field({
      type: apiWithoutContext.nonNull(apiWithoutContext.ID),

      resolve({
        value
      }) {
        return value.toString();
      }

    }),
    views,
    getAdminMeta: () => ({
      kind: config.kind
    }),
    ui: {
      createView: {
        fieldMode: 'hidden'
      },
      itemView: {
        fieldMode: 'hidden'
      }
    }
  }));
};

/* Validate lists config and default the id field */

function applyIdFieldDefaults(config) {
  var _config$db$idField;

  const lists = {};
  const defaultIdField = (_config$db$idField = config.db.idField) !== null && _config$db$idField !== void 0 ? _config$db$idField : {
    kind: 'cuid'
  };
  Object.keys(config.lists).forEach(key => {
    var _listConfig$db$idFiel, _listConfig$db;

    const listConfig = config.lists[key];

    if (listConfig.fields.id) {
      throw new Error(`A field with the \`id\` path is defined in the fields object on the ${JSON.stringify(key)} list. This is not allowed, use the idField option instead.`);
    }

    const idField = idFieldType((_listConfig$db$idFiel = (_listConfig$db = listConfig.db) === null || _listConfig$db === void 0 ? void 0 : _listConfig$db.idField) !== null && _listConfig$db$idFiel !== void 0 ? _listConfig$db$idFiel : defaultIdField);

    const fields = _objectSpread({
      id: idField
    }, listConfig.fields);

    lists[key] = _objectSpread(_objectSpread({}, listConfig), {}, {
      fields
    });
  });
  return lists;
}

/*
  This function executes the validation and other initialisation logic that
  needs to be run on Keystone Config before it can be used.
*/

function initConfig(config) {
  if (!['postgresql', 'sqlite'].includes(config.db.provider)) {
    throw new Error('Invalid db configuration. Please specify db.provider as either "sqlite" or "postgresql"');
  }

  return _objectSpread(_objectSpread({}, config), {}, {
    lists: applyIdFieldDefaults(config)
  });
}

exports.createSystem = createSystem;
exports.initConfig = initConfig;
exports.serializePathForImport = serializePathForImport;
exports.writeAdminFiles = writeAdminFiles;
